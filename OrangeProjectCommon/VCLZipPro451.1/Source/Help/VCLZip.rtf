{\rtf1\ansi\deff0\deftab720{\fonttbl
{\f0\fmodern Arial;}
{\f1\fmodern\fcharset0 Arial;}
{\f2\fnil\fcharset0 Courier New;}
{\f3\fnil Courier New;}
{\f4\fnil\fcharset0 MS Shell Dlg;}
{\f5\fnil\fcharset2 Symbol;}
{\f6\fnil\fcharset0 Arial;}
{\f7\fnil Arial;}
{\f8\fmodern Courier New;}
{\f9\fmodern\fcharset0 Courier New;}
}
{\colortbl
 ;
\red255\green0\blue0;
\red0\green128\blue0;
\red128\green0\blue0;
\red0\green0\blue255;
\red0\green0\blue0;
\red255\green0\blue255;
}
{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG2}
{\up $}{\footnote {\up $} Blocked Zip Files}
{\up K}{\footnote {\up K} Blocked Zip Files;BlockSize;Spanning;}
{\up A}{\footnote {\up A} BlockedArchives}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Creating Blocked Zip Files\b0\fs24   
\par \pard\fs22   
\par \cf1\f1 NOTE:\cf0   This is one of the biggest changes between VCLZip Lite and VCLZip Pro.  VCLZip Lite calls the \cf2\strike OnGetNextDisk Event \cf3\strike0{\v Scribble2505}\cf0  when creating new blocks, whereas VCLZip Pro calls the \cf2\strike OnFileNameForSplitPart event\cf3\strike0{\v Scribble2750}.
\par \cf0\f0 
\par Blocked zip files are spanned zip file images that are created in specific sized physical blocks directly to the hard drive.   This allows you to create spanned zip files without actually creating them directly to diskettes first.   This may be useful, for instance, if you are creating a master installation disk set that will be copied to diskettes many times.  The result of a Blocked zip file will be a series of files, the first with an extension of '\f1 .zip\f0 .\f1 z\f0 01', the second with an extension of '\f1 .zip\f0 .\f1 z\f0 02' and so on. So if you specified a ZipName of 'BACKUP.ZIP', the result will be 'BACKUP.\f1 ZIP.Z\f0 01' ... 'BACKUP.\f1 ZIP.\f0 nnn'\f1 ... BACKUP.ZIP\f0 .\f1   (Notice the last block simply has the .ZIP extension and it is the one that should be used to opened the archive).\f0   These files are structurally the same as a \strike Spanned Disk Set\strike0\fs24{\v PG700}\fs22  only all files are created in one destination directory instead of to separate disks.  
\par 
\par Create a Blocked Zip File by following these steps: 
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f1 Optionally create your own \cf2\strike OnFileNameForSplitPart event\cf3\strike0{\v Scribble2750}\cf0\f0 
\par {\pntext\f5\'B7\tab}Set the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  to a path and filename in a directory with enough room to hold the entire backup.
\par {\pntext\f5\'B7\tab}Set the \strike MultiMode Property\strike0\fs24{\v Scribble2465}\fs22  to \cf4 mmBlocks\cf0 
\par {\pntext\f5\'B7\tab}Set the \strike FirstBlockSize Property\strike0\fs24{\v Scribble3120}\fs22  to the size you want the first file to be in bytes.
\par {\pntext\f5\'B7\tab}Set the \strike BlockSize Property\strike0\fs24{\v Scribble3110}\fs22  to the size you want all other blocks to be in bytes.
\par {\pntext\f5\'B7\tab}Specify the files you want zipped by adding file specs and/or wildcards to the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22 .
\par {\pntext\f5\'B7\tab}Call the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22 . 
\par \pard   
\par \b Example:
\par \b0  
\par \cf4\f2\fs20  With VCLZip1 do 
\par \pard\tx360\tab begin 
\par \pard\tx720\tab ZipName := 'C:\\SOMEDIR\\BACKUP.ZIP'; 
\par \tab MultiZipInfo.MultiMode := mmBlocks; 
\par \tab MultiZipInfo.FirstBlockSize := 700000; /*approximately 1/2 diskette*/ 
\par \tab MultiZipInfo.BlockSize := 1457600;     /*entire diskette*/ 
\par \tab FilesList.Add('C:\\MYFILES\\*.*'); 
\par \tab Recurse := True;   \tab\tab\tab    /* Recurse directories*/ 
\par \tab Zip; 
\par \pard\tx360\tab end; 
\par \pard\cf0  \f0\fs22  
\par All of the files will be created automatically\f1  to your hard drive\f0 .  There is no need to insert new disks for this operation.  
\par When transferring Blocked Zip files onto disks, if you wish to make a standard pkzip compatible spanned disk set, be sure:
\par   
\par 1) You should give each file \f1 just \f0 the .ZIP extension on the disks. 
\par  
\par 2) The component (or any unzip utility) expects to find the correct disk label on each disk. For example, Disk 1 should be labeled as PKBACK# 001, Disk 2 should be labeled PKBACK# 002, etc.  If the disk label is not what the component expects, the component will not operate correctly, unless...  
\par Set the \strike CheckDiskLabels Property\strike0\fs24{\v Scribble2335}\fs22  to false if you do not want the component to check the disk labels when unzipping spanned disk sets.  You must make sure your program asks for the correct disk and has a way of verifying the correct disk number.  
\par \f1 
\par One good reason you may wish to write your own \cf2\strike OnFileNameForSplitPart  \cf3\strike0{\v Scribble2750}\cf0 event is if you wish to write blocked zip files to CD as they are created.  If you are creating backups to CDR then you can't write directly to CD, you must create the file first and then burn it to the CD using your CD burner's api.  So you might do something like the following:
\par \pard\li277\ri18\tx720\cf5\f2\fs20 
\par \cf4 procedure TMainForm.OnFileNameForSplitPart(\f3 Sender: TObject; \b var\b0  FName: \b String\b0 ; PartNum: Integer; SplitType: TSplitPartType);
\par \f2 begin
\par \tab // When zipping, we need new disk and we want to burn the block
\par \tab // just written to the newly inserted CD
\par \tab If (VCLZip1.\strike OperationMode \strike0{\v Scribble2540}= omZip) then
\par \tab begin
\par \tab\tab // call default to get filename (FName) for block just written to HD
\par \tab\tab VCLZip1.\strike DefaultFileNameForSplitPart\strike0{\v Scribble2695}(FName,PartNum-1,SplitType);
\par \tab\tab // Your code can go here to burn the block just written to HD
\par \tab\tab // to your CDR.
\par \tab\tab\tab // Prompt for next disk
\par \tab\tab\tab // Call CD burning api to burn file to CD
\par \tab end;
\par \tab // Whether zipping or unzipping return the filename that was asked for
\par \tab // using VCLZip's default method for getting filename
\par \tab VCLZip1.\strike DefaultFileNameForSplitPart\strike0{\v Scribble2695}(FName,PartNum,SplitType);\tab 
\par end;\f4 
\par \pard\cf0\f1\fs22 
\par 
\par \f0 
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG3}
{\up $}{\footnote {\up $} Examples}
{\up K}{\footnote {\up K} Examples;UnZipping;}
}
\viewkind4\uc1\pard\lang1033\b\f0\fs30 Using TVCLUnZip\b0\fs24  
\par 
\par \fs22 Basic procedure for programming the VCLUnZip component: 
\par  
\par If you simply wish to extract all files from a particular zip file it is as easy as just specifying the ZipName and DestDir properties and then call the UnZip method.  That's it.  If you wish to do more, the following pseudo example gives a very cursory overview of the kinds of  things you can do...  
\par \cf4   
\par \pard\li240 MemoPad: TMemo; 
\par Unzipper: TVCLUnZip; 
\par NumUnzipped: Integer; 
\par 
\par \pard USES ... VCLUnZIp, kpZipObj; \cf1  <-kpZipObj is needed if you use some of the defined types\cf4  ...  
\par 
\par \pard\li240 With Unzipper do 
\par \pard\li360 begin 
\par \pard\li600 ZipName := 'c:\\test\\Zipfile.zip'    // set the zip filename 
\par ReadZip;                           // open it and read its information 
\par // List filenames in zip file 
\par for i := 0 to Count-1 do 
\par \pard\li960 MemoPad.Lines.Add( Filename[i] + #9 + Pathname[i] ); 
\par \pard\li480 // extract some files  
\par \pard\li600 // determine which files to unzip 
\par FilesList.Add( '*.cpp' );              // unzip all .cpp files 
\par FilesList.Add( 'myprog.exe' );   // unzip myprog.exe 
\par FilesList.Add( '?<0-9>*\\*.h' );      // .h files, if 2nd letter of dir starts with digit only 
\par FilesList.Add( Filename[Count-1] );   // extract last entry in zipfile 
\par DoAll := False;                  // Don't unzip all files 
\par DestDir := 'c:\\mydir'         // Set destination directory 
\par RecreateDirs := False;     // don't recreate directory structures 
\par RetainAttributes := True   // Set attributes to original after unzipping  
\par NumUnzipped := Unzip;                        // Extract files, return value is the number of files actually unzipped 
\par \pard\li360 end; \cf0   
\par \pard  
\par \fs24 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4}
{\up $}{\footnote {\up $} ZLibDecompressStream method}
{\up +}{\footnote {\up +} zlib:000050}
{\up K}{\footnote {\up K} Decompress;Http Compression;ZLib;ZLibDecompressStream;}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 ZLibDecompressStream method\cf3\cf0\b0\f7\fs20 
\par \pard 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par  \b procedure \b0 ZLibDecompressStream(inStream, outStream: TStream; HttpCompression: Boolean = False);
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Description
\par 
\par \pard\b0\f1 Decompresses data in \cf4 inStream \cf0 into \cf4 outStream \cf0 in ZLib format.  The ZLib compression and decompression routines are good for compressing a single data source most efficiently.  For instance if compressing data to be sent through the network.  The data in inStream should have previously been compressed in the ZLib format, not as a zip archive.  
\par 
\par Set \cf4 HttpCompression \cf0 to True if you expect the compressed data in inStream to lack ZLib headers.  This would most likely be if the data is compressed for http1.1 compliant browsers, that is, compression of web pages.  In other words, if you compressed the data using ZLibCompressStream with HttpCompression set to True, you also need to set this to True when uncompressing. \f7\fs20 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble5}
{\up $}{\footnote {\up $} ZLibCompressStream method}
{\up +}{\footnote {\up +} zlib:000020}
{\up K}{\footnote {\up K} Compress;Http Compression;Stream Compression;ZLib;ZLibCompressStream;}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 ZLibCompressStream method\cf3\cf0\b0\f7\fs20 
\par \pard 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  \b procedure \b0 ZLibCompressStream(inStream, outStream: TStream; HttpCompression: Boolean = False);
\par 
\par \b\fs22 Description
\par 
\par \pard\b0\f1 Compresses data in \cf4 inStream \cf0 into \cf4 outStream \cf0 in ZLib format.  The ZLib compression and decompression routines are good for compressing a single data source most efficiently.  For instance if compressing data to be sent through the network.  Data is not compressed into a PKZip archive in this case.
\par 
\par Note that setting \cf2\strike PackLevel \cf3\strike0{\v Scribble3320}\cf0 determines the level of compression for ZLib compression just as it does when compressing pkzip archives.
\par 
\par Setting \cf4 HttpCompression \cf0 to True will cause the data to be compressed without the normal ZLib headers.  This is mainly for compressing web information for http1.1 compliant compression, that is, compression of web pages.  If you set this to true and if you use any of the ZLib decompression methods to decompress the same data you should set HttpCompression to true when calling that method too.\f7\fs20 
\par 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble6}
{\up $}{\footnote {\up $} ZLibDecompressBuffer method}
{\up +}{\footnote {\up +} zlib:000040}
{\up K}{\footnote {\up K} Decompress;Http Compression;ZLib;ZLibDeCompressBuffer;}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 ZLibDecompressBuffer method\cf3\cf0\b0\f7\fs20 
\par \pard 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  \b procedure \b0 ZLibDecompressBuffer(const inBuffer: Pointer; inSize: Integer;
\par                   out outBuffer: Pointer; out outSize: Integer; outEstimate: Integer = 0; HttpCompression: Boolean = False);
\par 
\par \b\fs22 Description
\par 
\par \pard\b0\f6\fs20 Decompresses data in \cf4 inBuffer\cf0 .  Resulting decompressed data will be placed in \cf4 outBuffer\cf0 .  \cf4 inSize \cf0 is the size of inBuffer.  \cf4 outSize \cf0 is the resulting size of the decompressed buffer.  You may pass in an estimate of the resulting size in \cf4 outEstimate\cf0 , or let VCLZip estimate for you. Regardless, the resulting outBuffer will be the same size as the amount of decompressed data.
\par 
\par Set \cf4 HttpCompression \cf0 to True if the compressed data was previously compressed with no ZLib headers. This would mainly be used for http1.1 browser compliant compression. So if the data was previously compressed with one of the ZLib compression methods and HttpCompression was set to true, then you should set HttpCompression to True when uncompressing also.
\par \f7 
\par 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble7}
{\up $}{\footnote {\up $} ZLibDecompressString method}
{\up +}{\footnote {\up +} zlib:000060}
{\up K}{\footnote {\up K} Decompress;Http Compression;String Compression;ZLib;}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 ZLibDecompressSt\f6 ring\f7  method\cf3\cf0\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  \b function \b0 ZLibDecompressString(const s: string; HttpCompression: Boolean = False): String;
\par 
\par \b\fs22 Description
\par 
\par \pard\b0\f6\fs20 Returns the String result of decompressing the string \cf4 s \cf0 that is passed in.  The data in the string passed in should have been compressed in the ZLib format.  Set \cf4 HttpCompression \cf0 to True if the data was previously compressed with no ZLib headers.\f7 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble8}
{\up $}{\footnote {\up $} ZLibCompressBuffer method}
{\up +}{\footnote {\up +} zlib:000010}
{\up K}{\footnote {\up K} Compress;Http Compression;ZLib;ZLibCompressBuffer;}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 ZLibCompressBuffer method\cf0\b0\f7\fs20 
\par \pard 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  \b procedure \b0 ZLibCompressBuffer(const inBuffer: Pointer; inSize: Integer;
\par                               out outBuffer: Pointer; out outSize: Integer; HttpCompression: Boolean = False);
\par \b\fs22 Description
\par 
\par \pard\b0\f6\fs20 Compresses data in \cf4 inBuffer\cf0 .  Resulting Compressed data will be placed in \cf4 outBuffer\cf0 .  \cf4 inSize \cf0 is the size of inBuffer.  \cf4 outSize \cf0 is the resulting size of the Compressed buffer. 
\par 
\par \f1 Note that setting \cf2\strike PackLevel \cf3\strike0{\v Scribble3320}\cf0 determines the level of compression for ZLib compression just as it does when compressing pkzip archives.\f6 
\par 
\par Set \cf4 HttpCompression \cf0 to True if you want to compress the data with no ZLib headers. This would mainly be used for http1.1 browser compliant compression. If you set this to True and then go to decompress the data with one of the ZLib decompress methods then you should set HttpCompression to True when uncompressing also.
\par \f7 
\par 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble10}
{\up $}{\footnote {\up $} Overview}
{\up K}{\footnote {\up K} Overview; Contents}
}
\viewkind4\uc1\pard\keepn\b\f0\fs30 V\f1 C\f0 LZip \f1 4\f0 , The Native Delphi Zip/UnZip Component  \b0\fs24 
\par \pard\tx2400\strike\fs22 TVCLZip Component\strike0\fs24{\v Scribble3200}\fs22\tab\strike TVCLUnZip Component\strike0\fs24{\v Scribble2300}\fs22   \cf2\strike TSFXConfig component\cf3\strike0{\v Scribble4010}\cf0 
\par \pard\b\strike 
\par \f1 Register\f0 ing VCLZip\b0\strike0\fs24{\v PG2000}\fs22  \b\f1 
\par \b0 
\par \cf2\b\strike Notes for current VCLZip Lite users upgrading to VCLZip Pro\cf3\strike0{\v Scribble15}
\par 
\par \cf2\strike\fs28 What's new in this version\cf3\strike0\fs22{\v Scribble13}
\par \cf0\f0 
\par \b0\strike Creating a Zip File\strike0\fs24{\v PG87}\fs22  
\par \strike UnZipping Files\strike0\fs24{\v PG3}\fs22  
\par \strike Creating Spanned Disk Zip Files\strike0\fs24{\v PG700}\fs22  
\par \strike Creating Blocked Zip Files\strike0\fs24{\v PG2}\fs22  (Creating Spanned Disk Images directly to hard drive) 
\par \strike Using Streams\strike0\fs24{\v PG88}\fs22  (Including Stream to Stream zipping/unzipping) 
\par \strike UnZipping to Memory Buffers\strike0\fs24{\v Scribble2650}\fs22  
\par \strike Zipping from Memory Buffers\strike0\fs24{\v Scribble3410}\fs22  
\par \strike Creating a Self Extracting Zip File\strike0\fs24{\v PG174}\fs22  
\par \strike Working with wildcards\strike0\fs24{\v PG18}\fs22  
\par \strike Streamlining Your Application\strike0\fs24{\v PG152}\fs22  
\par \strike Frequently Asked Questions\strike0\fs24{\v PG175}\fs22  
\par \strike Acknowledgments\strike0\fs24{\v PG176}\fs22  
\par 
\par \cf4 Be sure to check \f1 one of \f0 the following: 
\par  
\par \pard\li360\strike\f3\fs20 http://\f2 www.vclzip.com\cf3\strike0\f3{\v *! ExecFile("http://www.\f3 vclzip.com\f2 ")}\cf0\f0\fs22 
\par \cf4\strike\f3\fs20 http://vclzip.bizland.com \cf3\strike0{\v *! ExecFile("http://vclzip.bizland.com ")}
\par \cf0\f0\fs22 
\par \pard\cf4 for any additional or newer files.  
\par 
\par \cf0\ul\b\fs25 What is VCLZip?\ulnone\b0\fs22  
\par 
\par The VCLZip Delphi component allows you to add ZIP and UNZIP capabilites to your application. This component is different from most other "ZIP" development libraries in that it is written in 100% Delphi Object Pascal code and is full featured.  There are no DLL's to tote around.  This component links right into your application's executable. It is very easy to use.  Just SOME of the features include:
\par   
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li360\tx360 Create zip files fully compatable with PKZip 
\par {\pntext\f5\'B7\tab}Completely native Delphi VCL  (NO DLLS) 
\par {\pntext\f5\'B7\tab}Create Disk Spanning and Blocked zip files 
\par {\pntext\f5\'B7\tab}Delphi \f1 4, 5, 6,\f0  \f1 7, 2005, 2006 and 2007\f0  compatible
\par {\pntext\f5\'B7\tab}C++ Builder \f1  4, 5\f0  \f1 6, 2007, and 2007\f0  compatible
\par {\pntext\f5\'B7\tab}Zip directly from streams to zip files 
\par {\pntext\f5\'B7\tab}Unzip directly to streams from zip files 
\par {\pntext\f5\'B7\tab}Stream to Stream zipping and unzipping 
\par {\pntext\f5\'B7\tab}Unzip directly to memory buffers 
\par {\pntext\f5\'B7\tab}Zip directoy from memory buffers 
\par {\pntext\f5\'B7\tab}Create and read Zip and File Comments 
\par {\pntext\f5\'B7\tab}Create Self Extracting Zip Files (16 bit and 32 bit distributable 
\par \f1{\pntext\f5\'B7\tab}W\f0 indows sfx stubs included (source included for these\f1  too\f0 ) or use your own stubs) 
\par {\pntext\f5\'B7\tab}Complete support for encrypted files (encrypts as it zips) 
\par {\pntext\f5\'B7\tab}Save Relative Path information 
\par {\pntext\f5\'B7\tab}Unzip using Relative Paths (even if zip file wasn't created with relative path info)
\par \f1{\pntext\f5\'B7\tab}Use enhanced wildcards\f0  
\par {\pntext\f5\'B7\tab}Exclude List (tell VCLZip which files not to include (use wildcards too)) 
\par {\pntext\f5\'B7\tab}NoCompress (STORE) List (tell VCLZip which files to just store (use wildcards too) 
\par {\pntext\f5\'B7\tab}Set your own temp directory 
\par {\pntext\f5\'B7\tab}Plenty of events 
\par {\pntext\f5\'B7\tab}Long filenames, even the 16 bit VCLZip/VCLUnZip 
\par {\pntext\f5\'B7\tab}Includes comprehensive Zip Utility with source as demo 
\par {\pntext\f5\'B7\tab}Includes a small stream zipping demo 
\par {\pntext\f5\'B7\tab}Includes a context sensitive help file 
\par {\pntext\f5\'B7\tab}No Royalties! \f7\fs24 
\par \f1\fs22{\pntext\f5\'B7\tab}AES Strong Encryption\f7\fs24 
\par {\pntext\f5\'B7\tab}Zip64 capabilities, properties, methods and events:
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li680\tx500 Uncompressed, Compressed, and Archive file sizes can be up to 2^63-1 bytes in length.  
\par {\pntext\f5\'B7\tab}You can compress up to 2147483647 files into an archive.  This is compatible with PKZip's Zip64 format.  
\par {\pntext\f5\'B7\tab}If a file does not extend beyond any of the original limitations (filesizes of 4 gig or 65535 files) then no Zip64 format information is included in the archive.
\par {\pntext\f5\'B7\tab}property \cf2\strike isZip64 \cf3\strike0{\v Scribble2455}\cf0 - tells you when you are working with a zip file that is using Zip64 format.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f6 F\f7 aster processing due to linking to Zlib\f6  1.2.3\f7  object files for compression and decompression routines.
\par {\pntext\f5\'B7\tab}Blocked Zip Files (spanned zip archives split onto hard drive) 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li680\tx540\f6 C\f7 ompatible with PKZip and WinZip split archives file naming format. 
\par {\pntext\f5\'B7\tab}For backwards compatability you can tell VCLZip to use the old VCLZip filenaming format by using the \cf2\strike BlockMode \cf3\strike0{\v Scribble2315}\cf0 property.
\par {\pntext\f5\'B7\tab}
\par \pard\f0\fs22 VCLZip constists of two components.  TVCLUnZip which handles all of the viewing and unzipping responsibilities and TVCLZip which descends from TVCLUnZip and adds all of the zipping features. 
\par  
\par \b If your application requires both zip and unzip capabilities, just drop TVCLZip onto your application's form.  If all your application needs is unzipping capabilities then all you will need is the TVCLUnZip component.  You should never need both components at the same time for most purposes.
\par \b0   
\par VCLZip fully supports \strike Spanned Disk Zip Files\strike0\fs24{\v PG700}\fs22  as well as \strike Blocked Zip Files\strike0\fs24{\v PG2}\fs22 .  
\par All versions support long filenames completely.  
\par 
\par \strike Registering VCLZip\strike0\fs24{\v PG2000}\fs22  will get you all of the source code\f1  which works for all supported versions of Delphi and BCB\f0 .  The unregistered version will only work while the Delphi/BCB IDE is running. 
\par  
\par ** Please test the component out completely to your satisfaction before registering to be sure that it meets your requirements.  I do not guarantee that it is completely free from bugs.  This component has been well tested, but certainly not under all conditions. 
\par  
\par Included in this installation is a fully functional component.  When you \strike register\strike0\fs24{\v PG2000}\fs22  you will receive instructions for where to download a new installation containing all of the source code.  Once you install the components using the source code, you will be able to run your application outside of the Delphi/BCB IDE. You will also be put on a mailing list so that I can notify you of any upgrades or bug fixes. You will receive point releases at no charge.  You will also receive discounts on any major upgrades.
\par   
\par There is also a very complete zip utility which is useful as an example of how to use the component.  With the example you can open and view zip files, extract files from zip files, add files, create new zip files and even view files from within the zip files by double-clicking on any compressed file.  You can also add and modify file and zip comments as well as create self extracting zips and fix truncated zip files and even create and read Spanned Disk Sets and Blocked Zip Files. \f1 S\f0 elf extracting stubs are supplied, however VCLZip will create an SFX file with any stubs you supply.  
\par 
\par Please let me know of any bugs that you might find.  See the contact information below. 
\par  
\par \ul\b\fs25 Pricing and Support Philosophy\ulnone\b0\fs22  
\par I am trying to keep the price very low so as to make zip capabilites available to developers that can't afford the almost $200 price tags of most full featured ZIP libraries on the market today.  
\par Email support is available.  I will do my best to fix any bugs that are found AND to add any enhancements that you think would make this component more productive.  While I can't provide a 'round the clock' help desk support, I will do the best I can.  
\par 
\par \ul\b\fs25 Contact\ulnone\b0\fs22  
\par Please feel free to test this component thoroughly before registering.  I'll be glad to answer any questions you might have, just email me at  
\par 
\par \pard\li360\f1 vclzip-support\f0 @\f1 4warding\f0 .com  
\par 
\par \pard This address redirects mail to more than one of my email accounts so please to not be alarmed if you ever get a delivery failure message.  Chances are that your message made it to more than one of my accounts.  
\par The latest evaluation version of VCLZip and up-to-date information can be found on the WWW at 
\par 
\par \pard\li360\cf4\strike\f3\fs20 http://www.\f2 vclzip.com\cf3\strike0\f3{\v *! ExecFile("http://www.\f3 vclzip.com\f2 ")}\cf0\f0\fs22 
\par \cf4\strike\f3\fs20 http://vclzip.bizland.com \cf3\strike0{\v *! ExecFile("http://vclzip.bizland.com ")}\cf0\f0\fs22 
\par \pard 
\par  
\par \f7\fs20 
\par 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble11}
{\up $}{\footnote {\up $} ZLibCompressString method}
{\up +}{\footnote {\up +} zlib:000030}
{\up K}{\footnote {\up K} Compress;Http Compression;String Compression;ZLib;ZLibCompressString;}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 ZLibCompressString method\cf0\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \pard\b0\fs20 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640     \b function \b0 ZLibCompressStr(const s: string; HttpCompression: Boolean = False): string;
\par 
\par \b\fs22 Description
\par 
\par \pard\b0\f6\fs20 Returns the String result of compressing the string \cf4 s \cf0 that is passed in.  The data in the returned string will be compressed in the ZLib format.\f7 
\par 
\par \f1 Note that setting \cf2\strike PackLevel \cf3\strike0{\v Scribble3320}\cf0 determines the level of compression for ZLib compression just as it does when compressing pkzip archives.
\par \f7 
\par \f6 Set \cf4 HttpCompression \cf0 to True if you want to compress the data with no ZLib headers. This would mainly be used for http1.1 browser compliant compression. If you set this to True and then go to decompress the data with one of the ZLib decompress methods then you should set HttpCompression to True when uncompressing also.
\par \f7 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble13}
{\up $}{\footnote {\up $} What's New in This Version}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 What's New in This Version\cf3\cf4 
\par \pard 
\par \cf0\fs28 Version 4.00 Build 1
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\fs20 AES Encryption: \b0 Besides standard PKZip style encryption, VCLZip now supports AES encryption compatible with PKZip and WinZip implementations.\b\fs28 
\par \cf2\b0\strike\fs20{\pntext\f5\'B7\tab}EncryptStrength property\cf3\strike0{\v Scribble2554} \cf0 Sets the encryption strength.  The choices are \f2 one of esPKStandard, esAES128, esAES192, esAES256).\f6\fs28 
\par \cf2\strike\fs20{\pntext\f5\'B7\tab}EncryptionStrength property\cf3\strike0{\v Scribble2553}\cf0  Reads the encryption strength for a particular file in an archive\fs28 
\par \pard\b 
\par Version 3.04 Build 1
\par \b0\f7\fs20 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f6 New ZLib methods for optimized compression and decompression of single entities of data in standard ZLib format, without the overhead of the PKZip format.  This is excellent for compression of data to be sent across the net, compressing web pages (http compliant compression), blobs, etc.\f7 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-300\li520\tx180\tx300\cf2\strike\f6 ZLibCompressStream\cf3\strike0{\v Scribble5}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressStream\cf3\strike0{\v Scribble4}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibCompressBuffer\cf3\strike0{\v Scribble8}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressBuffer\cf3\strike0{\v Scribble6}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibCompressString\cf3\strike0{\v Scribble11}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressString\cf3\strike0{\v Scribble7}\cf0\f7 
\par \pard\fi-180\li180\tx180\tx300\f6 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\tx300 Overloaded TStream Methods for Delphi 4,5, BCB 4, and 5\f7 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-280\li520\tx180\tx300\cf2\strike\f6 UnZipToStream\cf3\strike0{\v Scribble2660}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}UnZipToStreamByIndex\cf3\strike0{\v Scribble2665}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZipFromStream\cf3\strike0{\v Scribble3415}\cf0\f7 
\par \pard\li240\tx180\tx300 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\tx300\f6 Special \cf2\strike OnGetNextTStream \cf3\strike0{\v Scribble3478}\cf0  Event for Delphi 4,5, BCB 4, and 5\f7 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-280\li520\tx480\tx300\f6 Allows zipping multiple TStreams in one process\f7 
\par \f6{\pntext\f5\'B7\tab}More efficient\f7 
\par \pard\fi-180\li180\tx180\tx300\f6 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\tx300 Capability to use the latest version of ZLib 1.2.1.  \f7 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-280\li520\tx480\tx300\f6 VCLZip currently uses 1.4.1 by default.\f7 
\par \f6{\pntext\f5\'B7\tab}By defining ZLIB121, VCLZip will use the latest version of ZLib which is included with the registered version.\f7 
\par \pard\fi-200\li220\tx480\tx300\f6 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li220\tx220\tx300 Some optimization improvements which should show some improvement in zipping and unzipping speed when using TkpStreams with D4, D5, BCB4, and BCB5.\f7 
\par \pard\li20\tx220\tx300 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li220\tx220\tx300\f6 Assorted small bug fixes\f7 
\par \pard\li20\tx220\tx300 
\par \pard\b\f6\fs28 Version 3.00 Build 1
\par \cf4\fs32 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li360\tx360\cf0\b0\f7\fs20 Zip64 capabilities, properties, methods and events:
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li680\tx500 Uncompressed, Compressed, and Archive file sizes can be up to 2^63-1 bytes in length.  
\par {\pntext\f5\'B7\tab}You can compress up to 2147483647 files into an archive.  This is compatible with PKZip's Zip64 format.  
\par {\pntext\f5\'B7\tab}If a file does not extend beyond any of the original limitations (filesizes of 4 gig or 65535 files) then no Zip64 format information is included in the archive.
\par {\pntext\f5\'B7\tab}property \cf2\strike isZip64 \cf3\strike0{\v Scribble2455}\cf0 - tells you when you are working with a zip file that is using Zip64 format.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f6 F\f7 aster processing due to linking to Zlib\f6  1.2.3\f7  object files for compression and decompression routines.
\par {\pntext\f5\'B7\tab}Blocked Zip Files (spanned zip archives split onto hard drive) 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li680\tx540 Now completely compatible with PKZip and WinZip split archives file naming format. 
\par {\pntext\f5\'B7\tab}For backwards compatability you can tell VCLZip to use the old VCLZip filenaming format by using the \cf2\strike BlockMode \cf3\strike0{\v Scribble2315}\cf0 property.
\par {\pntext\f5\'B7\tab}New method \cf2\strike OnFileNameForSplitPart \cf3\strike0{\v Scribble2750}\cf0 called just before each split filepart is created.  VCLZip supplies a default implementation of\f6  \f7 this method so for most purposes you won't need your own
\par {\pntext\f5\'B7\tab}method \cf2\strike DefaultFileNameForSplitPart \cf3\strike0{\v Scribble2695}\cf0 - VCLZip calls this internally if you don't define your own OnFileNameForSplitPart.  You can also call it from your own OnFileNameForSplitPart if you wish to add some processing to the default behavior\f6 .\f7 
\par {\pntext\f5\'B7\tab}property \cf2\strike BlockMode \cf3\strike0{\v Scribble2315}\cf0 - determines whether VCLZip uses PKZip/WinZip standard naming convention or VCLZip classic method.
\par {\pntext\f5\'B7\tab}method \cf2\strike DefaultGetNextDisk \cf3\strike0{\v Scribble2700}\cf0 - VCLZip calls this internally if you don't define your own OnGetNextDisk.  You can also call it from your own OnGetNextDisk event if you wish to add some processing to the default behavior.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Properties for controlling which files are zipped...
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li660\tx520\f6  \cf2\strike\f7 IncludeHiddenFiles \cf3\strike0{\v Scribble3255}\cf0 - default False;
\par {\pntext\f5\'B7\tab} \cf2\strike IncludeSysFiles\cf3\strike0{\v Scribble3265}\cf0 : - default False;
\par {\pntext\f5\'B7\tab} \cf2\strike IncludeReadOnlyFiles\cf3\strike0{\v Scribble3260}\cf0 : - default True;
\par {\pntext\f5\'B7\tab} \cf2\strike IncludeArchiveFiles\cf3\strike0{\v Scribble3250}\cf0 : - default True;
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Event \cf2\strike OnGetNextStream \cf3\strike0{\v Scribble3475}\cf0 - Allows you to zip from multiple streams when using the ZipFromStream method. This improves performance since repeated calls to ZipFromStream causes the archive to be updated on each subsequent call.
\par {\pntext\f5\'B7\tab}property \cf2\strike ThisBuild \cf3\strike0{\v Scribble2598}\cf0 - Tells you the current build.  See also ThisVersion 
\par {\pntext\f5\'B7\tab}property \cf2\strike OnHandleMessage \cf3\strike0{\v Scribble2755}\cf0 - Handles interactive messages with VCLZip.  There is a default, so you don't need to define your own unless you wish to eliminate interactive messages and handle them on your own.  This is helpful if you are using VCLZip as a service or on a webserver for instance.
\par \f6{\pntext\f5\'B7\tab}property \cf2\strike RelativePathList\cf3\strike0{\v Scribble2565} which now allows creating an archive with multiple relative path anchor directories.  In the past this was only possible by repeated calls to the zip process with a new value for the \cf2\strike RootDir property\cf3\strike0{\v Scribble2580} which meant you were modifying a complete archive each time.  For backward compatability, setting RootDir will still set RelativePathList[0], so the behavior will be the same when setting RootDir.\cf0\f7 
\par \pard\cf4\b\f6\fs32 
\par \pard\li20\tx220\tx300\cf0\b0\f7\fs20 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble15}
{\up $}{\footnote {\up $} Notes for users upgrading from VCLZip Lite to VCLZip Pro}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 Notes for users upgrading from VCLZip Lite to VCLZip Pro\cf3\cf0\b0\f7\fs20 
\par \pard 
\par ******** \cf4\ul\fs24 Upgrading existing applications that \f6 currently \f7 use VCLZip 2.X \cf0\ulnone\fs20 **********
\par 
\par For the most part, existing applications will work as-is.  Just install VCLZip 3.X and recompile your code.  Here are some things to be aware of though...
\par 
\par \pard\fi-240\li240 1) If your app currently creates mmBlock archives (spanned directly to hard drive) and you define your own OnGetNextDisk in VCLZip 2.X, you should move your code from this event that handles mmBlock events to the new event OnFileNameForSplitPart. However, if you simply rely on VCLZip's default OnGetNextDisk then you don't have to worry about this.
\par 
\par 2) If your app creates mmBlock archives, the default naming convention has changed to match the PKZip/WinZip standard. If you wish to keep the same naming convention then set BlockMode := mbClassic.
\par 
\par 3) OnGetNextDisk and OnPrepareNextDisk events are called for the 1st disk now.  VCLZip 2.X only calls these events starting with the 2nd disk.
\par 
\par 4) properties CompressedSize[Index], UncompressedSize[Index], ZipSize are now Int64 types.
\par 
\par 5) Delphi 4, Delphi 5, BCB 4, and BCB5 are all capable of using the Zip64 format.  However they use the TkpHugeStream decendants which act just like TStreams except they handle files/stream sizes larger than 2gig. \f6 Normally you will never need to be aware of this,  unless you use the \cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf0 , \cf2\strike UnZipToStream\cf3\strike0{\v Scribble2660}\cf0 , or \cf2\strike ArchiveStream \cf3\strike0{\v Scribble2310} \cf0 features.  
\par 
\par     \cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf0  and \cf2\strike UnZipToStream\cf3\strike0{\v Scribble2660} \cf0 as well as \cf2\strike UnZipToStreamByIndex \cf3\strike0{\v Scribble2665} \cf0 have overloaded versions for D4, D5, BCB4, and BCB5 that take normal TStreams as parameters so that even if you do use these methods, you normally won't have to worry about any of this.  However, keep in mind that you should not unzip to a TStream in these versions of Delphi/BCB if the flle you are unzipping might be larger than 2 gig in size as TStream in these versions cannot handle files that large.
\par 
\par     If you currently work with the ArchiveStream property
\par 
\par     \f7 There is a TkpHugeFileStream and a TkpHugeMemoryStream \f6 defined in KPHSRMS.PAS \f7 which should handle 99% of all necessary actions.  If you currently work with VCLZip 2.X with TBlobStreams or some other type of streams, you can either define your own TkpBlobStream for instance which inherits from TkpHugeStream, or use the TkpHugeStream.CopyFrom(TStream, Count) and the TkpHugeStream.GetStream: TStream methods to give VCLZip your stream and get it back.  Ofcourse when using regular TStream decendants in D4,4,BCB4,and 5, you cannot create Zip64 archives.  If you use Delphi 6, 7, or BCB 6, you don't have to worry about any of this as the normal TS\f6 t\f7 ream is used \f6 (TkpHugeStream = TStream) \f7 by VCLZip and handles large file/stream sizes.
\par 
\par \f6 6) \cf2\strike RelativePathList\cf3\strike0{\v Scribble2565}\cf0  is a new property that is used to handle creating archives with relative path information. This property allows you to create an archive with multiple relative path anchor directories.  In past versions of VCLZip, this required multiple calls to the zip process while setting a new value for the \cf2\strike RootDir property\cf0\strike0{\v Scribble2580} which meant you were adding files to an existing archive with each subsequent call.  You should not have to change your current VClZip applications if they currently use the RootDir property for the relative path anchor directory because setting RootDir also adds the same value to RelativePathList[0].\f7 
\par 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG18}
{\up $}{\footnote {\up $} Wildcards}
{\up +}{\footnote {\up +} vclunzip:000930}
{\up K}{\footnote {\up K} Filenames;Pathnames;Wildcards;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Working with wildcards\b0\fs24   
\par \pard\fs22  
\par \pard Valid wildcard characters: 
\par \pard\fi-1200\li1200\tx1200\tx720 *\tab Matches any number of contiguous characters 
\par ?\tab Matches any single character 
\par <>\tab Encloses multiple possibilities for a single character 
\par ^\tab Matches anything but what follows inside <> 
\par !\tab Same as ^ 
\par -\tab Range of characters within <> 
\par *<>\tab Matches any number of contiguous characters as long is it satisfies the possibilites inside the following brackets.  
\par \pard\fi-1200\li1200\tx1200\b Examples:\b0   
\par \pard\fi-1200\li1200\tx1200\tx720 <a-h>\tab matches any single character from a through h 
\par <!a-h>\tab matches any single character that isn't a through h 
\par <anplx>\tab matches any single character as long as it is an a, n, p, l, or x. 
\par *<a-e>\tab Matches any contiguous characters as long as they are all a thru e 
\par *<!a-e>\tab Matches any contiguous characters as long as they are all NOT a thru e 
\par \pard   
\par \pard\fi-3000\li3000\tx3000\tx720 'ma?ch.*\tab Would match match.exe, mavch.dat, march.on, etc 
\par this <e-n>s a <!zy>est\tab Would match 'this is a test', but would not match 'this as a yest' 
\par \pard\fi-3000\li3000\tx3000 c:\\windows\\sys???\\*.ini\tab Would match c:\\windows\\system\\system.ini, c:\\windows\\sys001\\abc.ini, but not c:\\windows\\system1\\system.ini or c:\\windows\\sys\\defg.ini 
\par \pard   
\par Complex wildcards may be used when specifying which files are to be zipped.  This includes wildcard characters not only in the filename but also in the pathname.  This allows you to specify directories using wildcards, for instance:  
\par 
\par \pard\li240 VCLZip1.FilesList.add('c:\\test\\w*\\mycode*.pas');  
\par 
\par \pard would get all PAS files beginning with mycode in subdirectories under TEST that begin with the letter w.  Wilcards may be much more complex than this.  
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG62}
{\up $}{\footnote {\up $} GetDecryptHeaderByteByPtr}
{\up K}{\footnote {\up K} BCB;Encryption;GetDecryptHeaderByteByPtr;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 GetDecryptHeaderByteByPtr\b0\fs24   
\par \pard\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\f7 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \pard\cf0\b\f0\fs22 Declaration 
\par \f8 function\b0  GetDecryptHeaderByteByPtr( Passwrd: String; dh: BytePtr ): Byte; 
\par 
\par \b\f0 Description  
\par \b0 This method is mainly for use in BCB and is analogous to the \strike DecryptHeaderByte Method\strike0\fs24{\v Scribble2630}\fs22  which should be used if developing in Delphi.  
\par 
\par You should pass dh in as a 12 byte array that should previously be filled in by a call to \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22 .  
\par 
\par This function is used in conjunction with the \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  to determine if a password matches the password key of a file.  This function is only needed if doing low level work with passwords and encrypted zip files.  
\par 
\par See Also:  
\par 
\par \strike DecryptHeader\strike0\fs24{\v Scribble2370}\fs22  
\par \strike DecryptHeaderByte\strike0\fs24{\v Scribble2630}\fs22  
\par \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG87}
{\up $}{\footnote {\up $} Creating Zip Files}
{\up K}{\footnote {\up K} Creating Zip Files;Examples;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Creating a Zip File\b0\fs24   
\par \pard\fs22   
\par Creating a new zip file is very easy with VCLZip.  Just follow these steps: 
\par  
\par \pard\fi-360\li360\tx360\f1\bullet\tab\f0 Set the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  to a new filename.  It's best to include a full path!  
\par \f1\bullet\tab\f0 Add any filespecs or wildcards to the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22  that you wish to be zipped.  
\par \f1\bullet\tab\f0 Set any other options that you want.  
\par \f1\bullet\tab\f0 Call the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22   
\par \pard   
\par And that's it!!!  Here's an example: 
\par  
\par \cf4  With VCLZip1 do 
\par \pard\li120 begin 
\par \pard\li480 ZipName := 'C:\\BACKUP.ZIP'; 
\par \pard\li480\tx4800 FilesList.Add('C:\\MYFILES\\*.PAS');\tab /* Zip all .PAS files */ 
\par Recurse := True;\tab /* Recurse directories */ 
\par StorePaths := True;\tab /* Keep path information */  
\par PackLevel := 9;\tab /* Highest level of compression */ 
\par NumberZipped := Zip;\tab /* Return value of Zip is the actual number of files zipped */ 
\par \pard\li120 end; 
\par 
\par \pard\cf0 Be sure to include \b kpZipObj\b0  in your USES list if you set properties like OverwriteMode.  kpZipObj includes many definitions that you may use.  
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG88}
{\up $}{\footnote {\up $} Streams}
{\up +}{\footnote {\up +} vclunzip:000940}
{\up K}{\footnote {\up K} Examples;Streams;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Using Streams\b0\fs24   
\par \pard 
\par \f1 You can perform stream zipping in one of two ways:   Using either standard pkzip archive format or the ZLib format.  The standard PKZip format allows you to store multiple elements into a standard pkzip archive while the ZLib format allows one element to be zipped but does not carry the overhead of all of the pkzip headers.   Here are the pros and cons of each:
\par 
\par \cf4\b PKZip Format stream zipping
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\cf0\b0 Pro's
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li360\tx180 multiple elements may be compressed into one archive\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li380\tx180\f1 standard pkzip format\f0 
\par \f1{\pntext\f5\'B7\tab}All of VCLZip's properties and events apply\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f1 Con's\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-140\li340\tx180\f1 Extra overhead of pkzip format headers causes size to be larger\f0 
\par \pard\tx200\cf4\b\f1 
\par ZLib Format stream zipping\cf0\b0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Pro's\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-140\li340\tx180\f1 Smaller and more efficient due to very small header size\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f1 Con's\f0 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-140\li340\tx180\f1 Other than PackLevel, most properties and events do not apply.\f0 
\par \f1{\pntext\f5\'B7\tab}No filename or pathname is stored with the compressed data\f0 
\par \f1{\pntext\f5\'B7\tab}Only works with TStreams not TkpStreams.  (This only affects D4, D5, BCB4, and BCB5 as they are one and the same in later versions)\f0 
\par \pard\fi-180\li180\tx180 
\par \f1 For \ul\b ZLib Format stream zipping\ulnone\b0  see the following:
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-300\li520\tx180\tx300\cf2\strike\f6 ZLibCompressStream\cf3\strike0{\v Scribble5}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressStream\cf3\strike0{\v Scribble4}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibCompressBuffer\cf3\strike0{\v Scribble8}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressBuffer\cf3\strike0{\v Scribble6}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibCompressString\cf3\strike0{\v Scribble11}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZLibDecompressString\cf3\strike0{\v Scribble7}\cf0\f7 
\par \pard\fi-180\li180\tx180\f0 
\par \ul\b\f1 PKZip Format Stream Zipping\f0 
\par \pard\ulnone\b0\fs22 Zipping and UnZipping to and from streams is as easy as zipping to and from zip files.  This allows your application to read from and save directly to streams as if they were normal files.  You still have full control over all options like encryption, compression level, etc.  
\par 
\par The following example shows just how easy it is to do \b stream to stream\b0  compression and decompression.
\par  \cf4   
\par Say you have your data to be compressed in a TMemoryStream.  Pass it into the following to compress it.  The compressed stream will be returned.  
\par 
\par function CompressStream(StreamToCompress: TMemoryStream): TMemoryStream; 
\par begin 
\par \pard\li360 Result := TMemoryStream.Create; 
\par // \f1 Creating new compressed stream\f0  
\par VCLZip.\cf2\strike ArchiveStream \cf3\strike0{\v Scribble2310}\cf4 := \f1 TMemoryStream.Create\f0 ; 
\par // Compress the data from uncompressed stream into the ArchiveStream; 
\par VCLZip.\cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf4 (StreamToCompress, 'DummyFileName'); 
\par \f1 // Retrieve the resulting compressed stream
\par Result := VCLZip.ArchiveStream;\f0 
\par // Detach \f1 the\f0  compressed stream from VCLZip 
\par VCLZip.ArchiveStream := nil; 
\par \pard end; 
\par 
\par Now you have the returned stream which contains the compressed data.  You can do what you need with this stream.  Now uncompress it into a stream by passing it into the following function.  The decompressed stream will be returned. 
\par  
\par function UnCompressStream(StreamToDecompress: TMemoryStream): TMemoryStream; 
\par begin 
\par \pard\li360 // Point ArchiveStream at the compressed stream 
\par VCLZip.ArchiveStream := StreamToDecompress; 
\par // Create stream to uncompress into 
\par Result := TMemoryStream.Create; 
\par // Unzip using the same dummy filename as you used to zip it 
\par VCLZip.\cf2\strike UnZipToStream\cf3\strike0{\v Scribble2660}\cf4 ( Result, 'DummyFileName'); 
\par // \f1 We're d\f0 one with the compressed stream 
\par VCLZip.ArchiveStream := nil; 
\par \pard end; 
\par 
\par \cf0\b\f1\fs30 Tip: Using TStreams other than TMemoryStream\f0  \b0\fs26  
\par \cf4\fs22 
\par \cf0\f1 You can always use CopyFrom or SaveToStream to put the contents of ArchiveStream into any type of TStream you wish.  Such as
\par 
\par \cf4  VCLZip.ArchiveStream.SaveToStream(yourTBlobStream);
\par \f0 
\par \cf0\f1 However, for increased performance, if are creating a new archive and you use VCLZip properly you can avoid having to copy from one stream to another.  As long as you never perform an operation that causes VCLZip to have to create a temporary stream you can retrieve ArchiveStream directly.  Any operation that causes VCLZip to modify an existing stream causes a temporary stream to be created.
\par If you are creating a new archive and you are compressing just one file into it, then no temporary file is create.  If you are creating a new archive and you are adding multiple files to the archive, you should use \cf2\strike OnGetNextStream \cf3\strike0{\v Scribble3475} \cf0 to add the additional streams.  This causes VCLZip to add all of the streams in one operation.
\par If you use the above recommendations then in the above example, you could replace the instances of TMemoryStream with any type of TStream and it should still work.
\par \f0 
\par \b\f1\fs30 When Using Delphi 4, 5, BCB 4, or BCB5\f0  \b0\fs26  
\par \fs22  
\par \f1 When using earlier versions of Delphi or BCB, TStreams do not have Int64 capabilities.  For this reason, VCLZip works internally with TkpStreams, which add this capability.  Therefore, when working with Streams, you have the choice of using decendants of TkpHugeStream which is defined in KPHSTRMS.PAS, or using the helper methods that allow you to work with normal TStreams.  Working with TkpHugeStreams is more efficient and, if you normally work with TFileStreams or TMemoryStreams, it is just as easy to work with TkpFileStream and TkpMemoryStream types.as they have the same properities and methods as their TStream counterparts.  For instance, in the above example you just need to change the instances of TMemoryStream to TkpMemoryStream and that is all the change that is necessary. 
\par 
\par However, if you need to work with other TStream decendants like TBlobStream or TStringStream, if you don't want to define your own similar decendants to TkpHugeStream, you can just slightly modify the code to use the overloaded methods of VCLZip.  They are:
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-280\li520\tx180\tx300\cf2\strike\f6\fs20 UnZipToStream\cf3\strike0{\v Scribble2660}\cf4\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}UnZipToStreamByIndex\cf3\strike0{\v Scribble2665}\cf0\f7 
\par \cf2\strike\f6{\pntext\f5\'B7\tab}ZipFromStream\cf3\strike0{\v Scribble3415}\cf0\f7 
\par \pard\f0\fs22 
\par \f1 So the above example might look something like this instead, if you were working with TStringStreams, when using earlier versions of Delphi/BCB:
\par 
\par \cf4\f0 function CompressStream(StreamToCompress: T\f1 String\f0 Stream): T\f1 String\f0 Stream; 
\par begin 
\par \f1       \cf1 // Use TkpMemoryStream instead for initial zipping.  We'll get the
\par       // compressed data back in a TStringStream after compressing\f0 
\par \pard\li360\cf4 VCLZip.\cf2\strike ArchiveStream \cf3\strike0{\v Scribble2310}\f1  \cf4\f0 := T\cf1\f1 kp\cf4\f0 MemoryStream.Create;
\par // Compress the data from uncompressed stream into the ArchiveStream;
\par \cf1\f1 //Overloaded version of ZipFromStream will be used\f0  
\par \cf4 VCLZip.\strike ZipFromStream\strike0{\v Scribble3415}(StreamToCompress, 'DummyFileName'); 
\par \cf1\f1 // Retrieve your compressed TStringStream
\par VCLZip.ArchiveStream.SaveToStream(Result);
\par VCLZip.ArchiveStream.Free;  // Need to do this when done
\par \cf4\f0 // Detach your compressed stream from VCLZip 
\par VCLZip.ArchiveStream := nil; 
\par \pard end; 
\par 
\par Now you have the returned stream which contains the compressed data.  You can do what you need with this stream.  Now uncompress it into a \f1 TStringS\f0 tream by passing it into the following function.  The decompressed stream will be returned.  
\par 
\par function UnCompressStream(StreamToDecompress: T\f1 String\f0 Stream): T\f1 String\f0 Stream; 
\par begin 
\par \pard\li360 // Point ArchiveStream at the compressed stream
\par \cf1\f1 // Use the special SetArchiveTStream method\f0 
\par \f1 VCLZip.SetArchiveTStream(StreamToDecompress);\f0  
\par \cf4 // Create stream to uncompress into 
\par Result := TMemoryStream.Create; 
\par // Unzip using the same dummy filename as you used to zip it 
\par \cf1\f1 // Overloaded version of UnZipToStream will be used\f0 
\par \cf4 VCLZip.\cf2\strike UnZipToStream\cf3\strike0{\v Scribble2660}\cf4 ( Result, 'DummyFileName'); 
\par \cf1\f1 VCLZip.ArchiveStream.Free;   // Need to do this\f0 
\par \cf4 // Done with the compressed stream 
\par VCLZip.ArchiveStream := nil; 
\par \pard end; 
\par \cf0 
\par 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble105}
{\up $}{\footnote {\up $} About VCLZip Pro}
{\up K}{\footnote {\up K} Lite;Pro;VCLZip;}
}
\viewkind4\uc1\pard\keepn\cf4\b\fs32 Differences between VCLZip Pro and VCLZip Lite\cf3\cf0\b0\f7\fs20 
\par \pard 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\cf1 Please test your application throroughly with this new version of VCLZip Pro.  While it has been tested and has even been used in at least two production applications for several months now\f6  prior to initial VCLZip Pro release\f7 , there are so many combinations of property settings, environment differences, and ways to use VCLZip that you should always test VCLZip completely in your application before deploying.
\par \pard\cf0 
\par *** New Zip64 capabilities, properties, methods and events:
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li660\tx180 Uncompressed, Compressed, and Archive file sizes can be up to 2^63-1 bytes in length.  
\par {\pntext\f5\'B7\tab}You can compress up to 2147483647 files into an archive.  This is compatible with PKZip's Zip64 format.  
\par {\pntext\f5\'B7\tab}If a file does not extend beyond any of the original limitations (filesizes of 4 gig or 65535 files) then no Zip64 format information is included in the archive.
\par {\pntext\f5\'B7\tab}property isZip64 - tells you when you are working with a zip file that is using Zip64 format.
\par \pard\li480\tx180 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Much faster processing due to linking to Zlib object files for compression and decompression routines.
\par \pard 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Blocked Zip Files (spanned zip archives split onto hard drive) 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li660\tx540 Now completely compatible with PKZip and WinZip split archives file naming format. 
\par {\pntext\f5\'B7\tab}For backwards compatability you can tell VCLZip to use the old VCLZip filenaming format by using the BlockMode property.
\par {\pntext\f5\'B7\tab}New method OnFileNameForSplitPart called just before each split filepart is created.  VCLZip supplies a default implementation of\f6  \f7 this method so for most purposes you won't need your own
\par {\pntext\f5\'B7\tab}method DefaultFileNameForSplitPart - VCLZip calls this internally if you don't define your own OnFileNameForSplitPart.  You can also call it from your own OnFileNameForSplitPart if you wish to add some processing to the default behavior\f6 .\f7 
\par {\pntext\f5\'B7\tab}property BlockMode - determines whether VCLZip uses PKZip/WinZip standard naming convention or VCLZip classic method.
\par {\pntext\f5\'B7\tab}method DefaultGetNextDisk - VCLZip calls this internally if you don't define your own OnGetNextDisk.  You can also call it from your own OnGetNextDisk event if you wish to add some processing to the default behavior.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Properties for controlling which files are zipped...
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi300\li180\tx180\f6  \f7 IncludeHiddenFiles - default False;
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-140\li620\tx480\tx660  IncludeSysFiles: - default False;
\par {\pntext\f5\'B7\tab} IncludeReadOnlyFiles: - default True;
\par {\pntext\f5\'B7\tab} IncludeArchiveFiles: - default True;
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 Event OnGetNextStream - Allows you to zip from multiple streams when using the ZipFromStream method. This improves performance since repeated calls to ZipFromStream causes the archive to be updated on each subsequent call.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 property ThisBuild - Tells you the current build.  See also ThisVersion      
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 property OnHandleMessage - Handles interactive messages with VCLZip.  There is a default, so you don't need to define your own unless you wish to eliminate interactive messages and handle them on your own.  This is helpful if you are using VCLZip as a service or on a webserver for instance.
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f6 VCLZip Pro works with Delphi 4 through Delphi 7 and BCB 4 through BCB 6.
\par {\pntext\f5\'B7\tab}When setting \cf2\strike ArchiveStream\cf3\strike0{\v Scribble2310}\cf0  using Delphi 4 or 5 or BCB 4 or 5 you should use one of the TkpHugeStream types or create your own stream class inherted from TKpHugeStream.  This allows Zip64 capabilities with these versions of Delphi.  For Delphi 6, 7, and BCB 6, you can use regular TStreams.
\par {\pntext\f5\'B7\tab}Future enhancements will be applied to VCLZip Pro, not VCLZip Lite
\par {\pntext\f5\'B7\tab}Supports PKZip Zip64 format
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-320\li580\tx560 Removes the file size limitations of VCLZip Lite - up to 2^63-1 bytes
\par {\pntext\f5\'B7\tab}Removes the number of files limitation of VCLZip Lite - up to 2147483647 files
\par {\pntext\f5\'B7\tab}Faster than VCLZip Lite - compression and decompression uses standard ZLib, written in C
\par {\pntext\f5\'B7\tab}If normal limitations are not reached, then format of zip file will be normal PKZip format, no Zip64 formatting will be included
\par \pard\f7 
\par \cf4\b\f6\fs32 About VCLZip Lite\cf0\b0\f7\fs20 
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200\f6 VCLZip Lite works with all versions of Delphi/BCB\f7 
\par \f6{\pntext\f5\'B7\tab}Limits\f7 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-280\li520\tx540\f6 File sizes up to 2 gig\f7 
\par \f6{\pntext\f5\'B7\tab}Archives hold up to 65535 files\f7 
\par \f6{\pntext\f5\'B7\tab}Does not create PKZip/WinZip compatible split/blocked archives (does create pkzip/winzip compatible spanned archives)\f7 
\par \f6{\pntext\f5\'B7\tab}Has most but not all of the events that VCLZip Pro has\f7 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG152}
{\up $}{\footnote {\up $} Streamlining}
{\up K}{\footnote {\up K} Conditionals;Streamlining;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Streamlining Your Application\b0\fs24   
\par \pard\fs22   
\par If there are certain features of VCLZip/VCLUnZip that you know you don't need, it is possible to "streamline" things a little by removing support for some features and thereby removing the code and data that supports those features from your executable.  The table below shows you which conditionals to define in the project options dialog box in order to remove particular features: 
\par  
\par \pard\fi-2400\li2400\tx2400\tx720\cf4\ul\b Define Conditional\ulnone\tab\ul If you don't need support for\cf0\ulnone\b0   
\par \b NOSTREAMBUFF\b0\tab the additional speed of buffered file i/o 
\par \b INFLATE_ONLY\b0\tab earlier versions of PKZip decompression 
\par \pard\fi-2400\li2400\tx2400 By defining \b MAKESMALL\b0  you can reduce the size of you application dramatically.  This removes all dependencies on the Dialogs, Forms, Controls, and FileCtrl units, which results in a smaller footprint.  This can be quite useful when putting VCLZip into a DLL for instance.  In order to make this work, go into your Project | Options and select the Directories/Conditionals tab and enter MAKESMALL in the conditional defines text box.  In Delphi you can add this conditinal define to the project options of your application that uses VCLZip and then do a "build all".  In BCB you will have to add this to the project options of the package that contains VCLZip and then rebuild the package. 
\par  
\par If you define \b MAKESMALL\b0 , the only things you lose are:
\par   
\par a) ZIP file open dialog box that appears when the ZipName is set to "?" 
\par b) Select Directory dialog box that appears when the DestDir is set to "?" 
\par c) Changing the cursor to an hour glass during some operations. 
\par \pard\tx2400 
\par By defining \b NO_RES\b0 , this avoids using the .RES file that contains strings that are used within VCLZip for things l\f1  l\f0 ike\f1  \f0 MessageBox messages.  Your strings will instead be compiled directly into the code.  This will ofcourse make it more difficult to internationalize you code and may result in poorer memory use, so you will most likely not want to define NO_RES.
\par   
\par \f1 B\f0 y selecting the Asserts compiler option you will turn on some assert statements that have been added to the compression process.  In general you should never need these so you should be sure this isn't defined in order to maximize speed.  
\par 
\par Also, for speed purposes, be sure to turn off all error checking options like stack overflow and I/O checking. These kinds of options can slow down the zipping and unzipping processes quite a bit.  
\par \pard\fi-2400\li2400\tx2400  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG174}
{\up $}{\footnote {\up $} SFX}
{\up K}{\footnote {\up K} Examples;SFX;}
}
\viewkind4\uc1\pard\lang1033\b\f0\fs30 Creating a Self Extracting Zip File\b0\fs24  
\par \fs22 If you create a Self Extracting Executable (SFX), The resulting zip file will have the same name as the original zip archive except that it will have an extention of \cf4 .EXE\cf0 . This will allow people to unzip files in your zip file without needing to have any kind of unzip utility themselves.  You can do this in two ways, with VCLZip  
\par Use the \strike MakeSFX Method\strike0\fs24{\v Scribble3440}\fs22  to create a SFX if you have an already existing zip file that you wish to turn into an SFX. 
\par 
\par Use the \strike MakeNewSFX\strike0\fs24{\v Scribble3395}\fs22  method to create a SFX  and zip the files that it will contain, all in one step.  With this method, you also have the capability to add configuration information to the zip file if your stub is capable of this.  VCLZip is distributed with a 32bit sfx stub that does have this capability by using the \strike TSFXConfig Component\strike0\fs24{\v Scribble4010}\fs22  to create the configuration block.
\par   
\par Here is an example of using the MakeSFX method:  
\par 
\par If you have a zip file called data.zip that you want to turn into a self extracting zip file and your SFX stub is called sfx32.exe.  You might use the following code:  
\par \cf4  
\par begin 
\par \pard\li360 With VCLZip1 do 
\par \pard\li600 begin 
\par \pard\li960 ZipName := 'c:\\myfiles\\data.zip'      /* the zip archive you want to turn into an SFX */; 
\par MakeSFX( 'c:\\sfxstuff\\32bit\\sfx32.exe', True );  /* note that the second argument is meaningless at this time */ 
\par \pard\li600 end; 
\par \pard end; 
\par \cf0   
\par This will result in a file named \cf4 data.exe\cf0  in the same directory as data.zip.  The local, central,and end of central headers in data.exe will be modified to reflect their new offsets.  
\par 
\par Here is an example of using the MakeNewSFX method using TSFXConfig (defined in the unit\} along with the 32bit SFX stub that is included with VCLZip.  This example assumes that the stub is called ZipSFX32.bin and is located in the same directory as the running program.:
\par   
\par \cf4 USES   kpSFXCfg;  
\par VCLZip1.RootDir := 'd:\\test\\somedir\\';  \cf6\{ Start recursive search from here \}\cf4  
\par VCLZip1.FilesList.Add('*.pas'); \cf6\{ Zip all of the .pas files in the dir structure \}\cf4  
\par VCLZip1.Recurse := True;  \cf6\{ Recurse subdirectories \}\cf4  
\par VCLZip1.StorePaths := True;  \cf6\{ Save path information \}\cf4  
\par sfxcfg := TSFXConfig.Create(nil);  \cf6\{Create the TSFXConfig object or drop the component on your form \}\cf4  
\par with sfxcfg do 
\par \pard\li360 begin             \cf6\{ Set the options \}\cf4  
\par \pard\li720 UserCanDisableCmdLine := chkUserDisableCmd.Checked; 
\par UserCanChooseFiles := chkUserChooseFiles.Checked; 
\par UserCanChangeOverwrite := chkUserChangeMode.Checked; 
\par OverwriteMode := TsfxOverwriteMode(OverwriteGrp.ItemIndex); 
\par AutoExtract := chkAutoExtract.Checked; 
\par Caption := txtCaption.Text; 
\par DefaultPath := txtDefDest.Text; 
\par CmdLine := txtCmdLine.Text; 
\par InfoText := InfoTextFrm.InfoText.Text; 
\par InfoTitle := InfoTextFrm.InfoTitle.Text; 
\par sfxcfg.CreateHeader; 
\par \pard\li480 end; 
\par \pard\li360\cf6\{ Get the stub \}\cf4  
\par SFXStub := ExtractFilePath(Application.ExeName) + 'ZipSFX32.bin'; 
\par \cf6\{ Make the SFX file \}\cf4  
\par if FileExists(SFXFile) then 
\par \pard\li720 SysUtils.DeleteFile(SFXFile); 
\par \pard\li360 VCLZip1.MakeNewSFX(SFXStub, SFXFile, sfxcfg.theHeader, sfxcfg.HeaderLen); 
\par \pard\li120 end; 
\par 
\par \pard\cf0  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG175}
{\up $}{\footnote {\up $} FAQ}
{\up K}{\footnote {\up K} FAQ;Frequently Asked Questions;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Frequently Asked Questions\b0\fs24   
\par \pard\fs22   
\par \b Q:\b0  When I try to install the VCLZip component in\f1 to Delphi\f0 , I get an error that says VCLZip calls itself recursively.  
\par \b A:\b0  Be sure that the package you are installing the components into does not have the same name as any of the components that you are installing into it.  So don't name the package VCLZip or VCLUnZip.  
\par 
\par \b Q:\b0  When I try to set the property OverwriteMode := Always, I get an error that says Always is undefined.  
\par \b A:\b0  If you get this error for any property try adding \cf4 kpZipObj\cf0  to your USES list.  Most of the TYPEs are defined there. 
\par  
\par \b Q:\b0  When adding wildcards to the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  without any path information, zipping doesn't seem to work. Why is this?  
\par \b A:\b0  Please remember that you should never count on the DEFAULT DIRECTORY when zipping.  You should always supply a path in some way whether it is as part of the filename itself when added to the FilesList, or by using the \strike RootDir Property\strike0\fs24{\v Scribble2580}\fs22 .
\par   
\par \b Q:\b0  Why can't I add any comments or files to a spanned or blocked archive?  
\par \b A:\b0  The directory information for the archive must go at the end of the archive which will be on the last disk or possibly even spread over the last 2 or 3 or more disks, depending on how many files are in the archive and this directory information points to the files within that archive.  Adding, replacing, or modifying anything withing a spanned archive would cause enough disk swapping that it would be much easier to just recreate the whole thing.  Once a spanned disk set is created, it cannot be modified in anyway. 
\par  
\par \b Q:\b0  When I run my application with VCLZip on my own machine everything works fine.  But when I deploy the application to another system, I get an error that says something like "Class not registered".  Why is this?  
\par \b A:\b0  This error is most likely caused, not by VCLZip, but by some ActiveX component that is part of your application.  VCLZip does not use any OLE, OCX, or ActiveX in any way and should not cause this error.  
\par 
\par \b Q:\b0  Why do I get errors when trying to use an application that uses VCLZip, when I have \cf4 MagicZip\cf0  active on my system at the same time?  
\par \b A:\b0  This will happen for any application that works with zip files if MagicZip is active.  MagicZip causes zip files to look like normal directories when passed to your application.  There are two things that can help.  One is that you can tell MagicZip the name of your application through it's configuration options.  It maintains a list of applications that it will allow to see zip files normally. Second, I had a registered user tell me that he was able to avoid the problem all together by using names for the zip files in his application with extentions other than .ZIP.  
\par More to come...  
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG176}
{\up $}{\footnote {\up $} Acknowledgments}
{\up K}{\footnote {\up K} Acknowledgments;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Acknowledgments\b0\fs24   
\par \pard\fs22  
\par \pard I would like to acknowledge the following:  
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-360\li360\tx360\cf4\b\strike\f6 ZLib\cf3\b0\strike0\f3\fs20{\v *! ExecFile("http://www.zlib.org")}\f2  \cf0\f1\fs22 for the excellent zip/unzip engines.\f0   
\par \b{\pntext\f5\'B7\tab}Ray Lischner\b0 , who's buffered io TStream I borrowed (with a few modifications) from his excellent book, Secrets of Delphi 2.  
\par \b{\pntext\f5\'B7\tab}William Hall\b0  of Compucat Software for the freely distributable 16 bit SFX stubs\f1  and for hours of testing early versions of VCLZip\f0 .  
\par \b{\pntext\f5\'B7\tab}Robert Daignault\b0  for his excellent public domain TContain container classes.
\par \cf4\b\f6{\pntext\f5\'B7\tab}Alistair George\cf0\b0\f1  for helping me out with hours of testing my code for VCLZip Pro and his many great suggestions.\f0 
\par \cf4\b\f6{\pntext\f5\'B7\tab}Andreas Stroebel of \strike ASCOMP Software GmbH\cf3\b0\strike0\f3\fs20{\v *! ExecFile("http://www.ascomp.de")}\cf0\f1\fs22  for his help in testing VCLZip Pro and his motivation!\f0 
\par \cf4\b\strike\f6\fs24{\pntext\f5\'B7\tab}Dr. Brian Gladman\cf3\b0\strike0\f3\fs20{\v *! ExecFile("http://fp.gladman.plus.com/cryptography_technology/rijndael/index.htm")}\cf0\f1\fs22  for his AES encryption code.\cf3\f2\fs18 
\par \cf0\f0\fs22{\pntext\f5\'B7\tab}Most of all, my wife \b Jan\b0  for all the patience she has shown while I have spent hours upon hours developing VCLZip and VCLUnZip.  
\par \pard   
\par \pard  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG700}
{\up $}{\footnote {\up $} Spanning}
{\up K}{\footnote {\up K} Examples;Multi File Zips;Spanning;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Creating Spanned Disk Zip Files\b0\fs24   
\par \pard\fs22   
\par Spanned zip files are single zip files that span across multiple disks.   This allows you to backup more files than would otherwise fit onto a single disktette.  To create a spanned disk set do the following: 
\par  
\par \pard\fi-360\li360\tx360\f1\bullet\tab Optionally d\f0 efine an \strike OnGetNextDisk\strike0\fs24{\v Scribble2505}\fs22  event that will allow the disk to be swapped.   If you do not provide an OnGetNextDisk event, then \f1 VCLZip Pro will internally call the \cf2\strike DefaultGetNextDisk method\cf3\strike0{\v Scribble2700}\cf0\f0  \f1 which VCLZip Pro provides.\f0 
\par \f1\bullet\tab\f0 Set the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  to a path and filename that is on a removable disk such as 'A:\\BACKUP.ZIP'. 
\par \f1\bullet\tab\f0 Set the \strike MultiMode Property\strike0\fs24{\v Scribble2465}\fs22  to \cf4 mmSpan\cf0  
\par \f1\bullet\tab\f0 If you want VCLZip to write labels on the disks, like PKZIP does, then set the \strike MultiZipInfo.WriteDiskLabels\strike0\fs24{\v Scribble3140}\fs22  property to \cf4 True\cf0 .\f1  (note that with CD's this is sometimes difficult)\f0   The first disk will contain the label PKBACK# 001, the second will contain PKBACK# 002, and so on.  
\par \f1\bullet\tab\f0 Specify the files you want zipped by adding filespecs and/or wildcards to the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22 .  
\par \f1\bullet\tab\f0 Call the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22 . 
\par 
\par \pard  \cf1 IMPORTANT:  \cf0  Normally, PKZip compatible spanned zip files require that the LAST disk of the disk set be inserted first in order to open up the zip file.  This often creates confusion and is an annoyance.  VCLZip has the unique capability to create and read spanned zip files which will allow VCLZip to open a spanned zip file from the first disk.  This option does not cause the spanned zip file to be non-PKZip compatible as PKZip, WinZip, and all of the other zip utilities can still open and read the spanned zip file normally.  However, VCLZip will, if this option is set to True, write some extra information onto the first disk in a separate file.  VCLZip will detect this file if the first disk is inserted first, and read from it, the information it would otherwise need the last disk to obtain.  For further information see \strike SaveZipInfoOnFirstDisk\strike0\fs24{\v Scribble3135}\fs22 .  
\par 
\par \b Example:\b0   First, define your OnGetNextDisk procedure that allows the disk to be swapped. (Note that beginning with version 2.17, this step is optional.  If you do not provide an OnGetNextDisk event, then a default one is provided for you)...
\par  
\par \cf4 procedure TVCLZipForm.ZipperGetNextDisk(Sender: TObject;  NextDisk: Integer; var FName: String); 
\par var 
\par \pard\tx360\tab MsgArray: String; 
\par \pard begin 
\par \pard\tx360\tab Screen.Cursor := crDefault; 
\par \tab MsgArray := 'Please insert disk ' + IntToStr(NextDisk) + ' of the multi-disk set.'; 
\par \tab If MessageDlg(MsgArray,mtConfirmation,[mbOK,mbCancel],0) = mrCancel then 
\par \pard\tx720\tab FName := '';  /* Set FName to '' to cancel */ 
\par \pard\tx360\tab Screen.Cursor := crHourGlass; 
\par \pard end
\par  
\par \cf0 And in your code that does the zipping...\cf4  
\par  
\par With VCLZip1 do 
\par \pard\tx360\tab begin 
\par \pard\tx720\tab ZipName := 'A:\\BACKUP.ZIP'; 
\par \tab MultiZipInfo.MultiMode := mmSpan;   /* Set to span disks */ 
\par \tab MultiZipInfo.WriteDiskLabels := True;   /*Actually this is the default*/ 
\par \tab MultiZipInfo.SaveOnFirstDisk := 200000;  /* Optional to save room on first disk */ 
\par \tab FilesList.Add('C:\\MYFILES\\*.*'); 
\par \tab Recurse := True;   /* Recurse directories */ 
\par \tab Zip; 
\par \pard\tx360\tab end; 
\par \pard\cf0   
\par And that's it!  Each disk will be filled with a zip file part.  Each disk will contain a file by the same name, in the example above, each disk will contain a file called BACKUP.ZIP.  The file will take up as much room as is available on each disk. So, if you would like other files to be on any of the disks, be sure to put them there first.  
\par 
\par Also note that a spanned disk set can be created by copying individual files from a \strike  Blocked Zip File\strike0\fs24{\v PG2}\fs22 , each to a separate diskette.  
\par  
\par \fs24 
\par \pard\plain\f0

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} PG2000}
{\up $}{\footnote {\up $} Registration}
{\up K}{\footnote {\up K} Ordering;Registration;}
}
\viewkind4\uc1\pard\keepn\lang1033\b\f0\fs30 Registering VCLZip\b0\fs24  \cf3\fs22\cf0   
\par \pard 
\par The price for the VCLZip\f1  is:
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-200\li200\tx200 $99.95 per developer for the first year of support \f0 
\par \f1{\pntext\f5\'B7\tab}$79.95 per developer for each year afterward.\f0 
\par \f1{\pntext\f5\'B7\tab}7 licenses = a site license allowing unlimited use at a single business location\f0 
\par \pard\tx200 
\par There are no royalty fees.  You may not resell VCLZip or VCLUnZip as a Zip or UnZip component nor may you use VCLZip or VCLUnZip to create and sell a zip/unzip component. You may not redistribute the source code or the VCLZip or VCLUnZip DCU files (It must be compiled into your executable application).  If you would like to work out some other form of registration such as a site license or corporate license, please email me.  
\par 
\par \f1 The $99.95 subscription price allows you to receive all updates and priority support for one year.  When your subscription period ends, you can renew the subcription for $79.95.  The renewal period starts exactly when the prior subscription period ended.\f0 
\par 
\par \pard The most up-to-date information can always be found on the KpGb Software web site at:  
\par 
\par \pard\li240\cf2 http://www.\f1 vclzip.com
\par \cf0\f0  
\par \pard\ul\b\fs25 Paying with a check or Cash\ulnone\b0\fs22   
\par You may register directly with me if you are able to send a $US check.  If you would like to register in this way, please send me an email message (\cf2\f1 vclzip-support\f0 @\f1 4warding\f0 .com\cf0 ) in order to receive instructions on doing so. Once I receive the check, I will email the source code to you.  
\par You may also pay with wire transfer, $US check, EuroCheque, or cash to Shareit. See Registering via the Internet below for more details.  
\par 
\par \ul\b\fs25 Registering via the Internet\ulnone\b0\fs22   
\par You may register VCLZip online on the Internet at 
\par 
\par \pard\fi-20\li260\cf4\strike\f3\fs20 http://www.shareit.com/programs/183694.htm\cf3\strike0{\v *! ExecFile("http://www.shareit.com/programs/183694.htm")}\cf0\f0\fs22 . 
\par 
\par \pard Alternatively, you can go to \cf4\strike\f3\fs20 http://www.shareit.com\cf3\strike0{\v *! ExecFile("http://www.shareit.com")}\cf0\f0\fs22  and enter the program number there: 183694. 
\par   
\par \ul\b\fs25 VCLZip Delphi Component - Copyright 1997\f1 -2008\f0 , Kevin L. Boylan\ulnone\b0\fs22  
\par  
\par \fs24 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2300}
{\up $}{\footnote {\up $} TVCLUnZip component}
{\up +}{\footnote {\up +} vclunzip:000010}
{\up K}{\footnote {\up K} TVCLUnZip;TVCLUnZip component;}
{\up A}{\footnote {\up A} TVCLUnZip_Object;TVCLUnZip}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 TVCLUnZip component
\par \cf0\b0\fs16 
\par \pard\keepn\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\ul See also\cf3\ulnone{\v %Scribble2301}\tab\cf2\ul Properties\cf3\ulnone{\v %Scribble2302}\tab\cf2\ul Methods\cf3\ulnone{\v %Scribble2303}\tab\cf2\ul Events\cf3\ulnone{\v %Scribble2304}\f6  \cf5\f7\cf0\b\fs22 
\par \pard\cf5\b0\fs20 
\par \cf0\b\fs22 Description
\par 
\par \pard\b0\f0 The VCLUnZip component handles all unzipping responsibilities.  VCLUnZip is the base class for the VCLZip component. 
\par  
\par Note that all properties, methods, and events that apply to VCLUnZip will also apply to VCLZip.  
\par 
\par \cf1\b NOTE: \cf0\b0 If you only need to do UNZIPPING operations then you will only need the VCLUnZip component.  This will reduce your applications footprint over using the VCLZip component which handles both unzipping and zipping operations.  \f1 And if you need to zipping and unzipping operations, all you need is the VCLZip component, you should not use both.\f0 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2301}
{\up $}{\footnote {\up $} TVCLUnZip component - See also}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 See also
\par \cf0\b0 
\par \cf2\strike TVCLZip component\cf3\strike0{\v Scribble3200}\cf0 
\par \cf2\strike TSFXConfig component\cf3\strike0{\v Scribble4010}\cf0 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2302}
{\up $}{\footnote {\up $} TVCLUnZip - Properties}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Properties
\par \cf0\b0 
\par \cf3\{bmct runtime.bmp\}\cf5  Run-time only\tab\cf3\{bmct key.bmp\}\cf5  Key properties
\par \pard\tx200\tx640\cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ArchiveStream\cf3\strike0{\v Scribble2310}\cf5 
\par \f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike BlockMode\cf3\strike0{\v Scribble2315}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike BufferedStreamSize\cf3\strike0{\v Scribble2320}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike BufferLength\cf3\strike0{\v Scribble2325}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Busy\cf3\strike0{\v Scribble2330}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike CheckDiskLabels\cf3\strike0{\v Scribble2335}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike CompressedSize\cf3\strike0{\v Scribble2340}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike CompressMethod\cf3\strike0{\v Scribble2345}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike CompressMethodStr\cf3\strike0{\v Scribble2350}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Count\cf3\strike0{\v Scribble2355}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Crc\cf3\strike0{\v Scribble2360}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike DateTime\cf3\strike0{\v Scribble2365}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike DecryptHeader\cf3\strike0{\v Scribble2370}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DestDir\cf3\strike0{\v Scribble2375}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike DiskNo\cf3\strike0{\v Scribble2380}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DoAll\cf3\strike0{\v Scribble2385}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DoProcessMessages\cf3\strike0{\v Scribble2390}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike EncryptionStrength\cf3\strike0{\v Scribble2553}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike EncryptBeforeCompress\cf3\strike0{\v Scribble2395}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ExternalFileAttributes\cf3\strike0{\v Scribble2400}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike FileComment\cf3\strike0{\v Scribble2405}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike FileHasComment\cf3\strike0{\v Scribble2410}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike FileIsOK\cf3\strike0{\v Scribble2415}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Filename\cf3\strike0{\v Scribble2420}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike FilesList\cf3\strike0{\v Scribble2425}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike FlushFilesOnClose\cf3\strike0{\v Scribble2430}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike FullName\cf3\strike0{\v Scribble2435}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ImproperZip\cf3\strike0{\v Scribble2440}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike IncompleteZipMode\cf3\strike0{\v Scribble2445}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike IsEncrypted\cf3\strike0{\v Scribble2450}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike isZip64\cf3\strike0{\v Scribble2455}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike KeepZipOpen\cf3\strike0{\v Scribble2460}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike MultiMode\cf3\strike0{\v Scribble2465}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike NumDisks\cf3\strike0{\v Scribble2470}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike NumSelected\cf3\strike0{\v Scribble2475}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike OperationMode\cf3\strike0{\v Scribble2540}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OverwriteMode\cf3\strike0{\v Scribble2545}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Password\cf3\strike0{\v Scribble2550}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Pathname\cf3\strike0{\v Scribble2555}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RecreateDirs\cf3\strike0{\v Scribble2560}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RelativePathList\cf3\strike0{\v Scribble2565}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ReplaceReadOnly\cf3\strike0{\v Scribble2570}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RetainAttributes\cf3\strike0{\v Scribble2575}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RootDir\cf3\strike0{\v Scribble2580}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike Selected\cf3\strike0{\v Scribble2585}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SortMode\cf3\strike0{\v Scribble2590}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ThisVersion\cf3\strike0{\v Scribble2595}
\par \cf5\tab\cf3\{bmct key.bmp\}\tab\cf2\strike ThisBuild\cf3\strike0{\v Scribble2598}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike UnCompressedSize\cf3\strike0{\v Scribble2600}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ZipComment\cf3\strike0{\v Scribble2605}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ZipHasComment\cf3\strike0{\v Scribble2610}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ZipName\cf3\strike0{\v Scribble2615}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ZipSize\cf3\strike0{\v Scribble2620}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2303}
{\up $}{\footnote {\up $} TVCLUnZip - Methods}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Methods
\par \cf0\b0 
\par \cf3\{bmct key.bmp\}\cf5  Key methods
\par \pard\tx200\tx640\f6\tab\tab\cf2\strike Create\cf3\strike0{\v ! ALink("Create_Method")}\cf5 
\par \tab\tab\cf2\strike Destroy\cf3\strike0{\v ! ALink("Destroy_Method")}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike CheckArchive\cf3\strike0{\v Scribble2625}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DecryptHeaderByte\cf3\strike0{\v Scribble2630}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DecryptHeaderByteByPtr\cf3\strike0{\v Scribble2635}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZip\cf3\strike0{\v Scribble2640}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZipSelected\cf3\strike0{\v Scribble2645}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZipToBuffer\cf3\strike0{\v Scribble2650}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZipToBufferByIndex\cf3\strike0{\v Scribble2655}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZipToStream\cf3\strike0{\v Scribble2660}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UnZipToStreamByIndex\cf3\strike0{\v Scribble2665}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike AskForNewDisk\cf3\strike0{\v Scribble2670}\cf5 
\par \tab\tab\cf2\strike Assign\cf3\strike0{\v ! ALink("Assign_Method")}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike CancelTheOperation\cf3\strike0{\v Scribble2675}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ClearSelected\cf3\strike0{\v Scribble2680}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ClearZip\cf3\strike0{\v Scribble2685}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DefaultFileNameForSplitPart\cf3\strike0{\v Scribble2695}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DefaultGetNextDisk\cf3\strike0{\v Scribble2700}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike FillList\cf3\strike0{\v Scribble2705}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike GetDecryptHeaderPtr\cf3\strike0{\v Scribble2710}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike PauseTheOperation\cf3\strike0{\v Scribble2715}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ReadZip\cf3\strike0{\v Scribble2720}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ResetFileIsOK\cf3\strike0{\v Scribble2725}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RestartTheOperation\cf3\strike0{\v Scribble2730}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Sort\cf3\strike0{\v Scribble2735}\cf5 
\par \pard\li220\tx180\tx300\cf3\{bmct key.bmp\}\tab\cf2\strike ZLibDecompressStream\cf3\strike0{\v Scribble4}\cf0\f7 
\par \cf3\f6\{bmct key.bmp\}\tab\cf2\strike ZLibDecompressBuffer\cf3\strike0{\v Scribble6}\cf0\f7 
\par \pard\li220\tx180\tx300\cf3\f6\{bmct key.bmp\}\tab\cf2\strike ZLibDecompressString\cf3\strike0{\v Scribble7}\cf0\f7 
\par \cf3\f6 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2304}
{\up $}{\footnote {\up $} TVCLUnZip - Events}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Events
\par \cf0\b0 
\par \cf3\{bmct key.bmp\}\cf5  Key events
\par \pard\tx200\tx640\f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnDecrypt\cf3\strike0{\v Scribble2740}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnEndUnZip\cf3\strike0{\v Scribble2745}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnFileNameForSplitPart\cf3\strike0{\v Scribble2750}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnHandleMessage\cf3\strike0{\v Scribble2755}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnStartUnZip\cf3\strike0{\v Scribble2760}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OEMConvert\cf3\strike0{\v Scribble2480}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnBadCRC\cf3\strike0{\v Scribble2485}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnBadPassword\cf3\strike0{\v Scribble2490}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnFilePercentDone\cf3\strike0{\v Scribble2495}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnGetNextBuffer\cf3\strike0{\v Scribble2500}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnGetNextDisk\cf3\strike0{\v Scribble2505}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnInCompleteZip\cf3\strike0{\v Scribble2510}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnPromptForOverwrite\cf3\strike0{\v Scribble2515}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnSkippingFile\cf3\strike0{\v Scribble2520}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnStartUnZipInfo\cf3\strike0{\v Scribble2525}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnTotalPercentDone\cf3\strike0{\v Scribble2530}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnUnZipComplete\cf3\strike0{\v Scribble2535}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2310}
{\up $}{\footnote {\up $} ArchiveStream property}
{\up +}{\footnote {\up +} vclunzip:000020}
{\up K}{\footnote {\up K} ArchiveStream;Streams}
{\up A}{\footnote {\up A} TVCLUnZip_ArchiveStream;ArchiveStream_Property;ArchiveStream}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ArchiveStream property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ArchiveStream: TkpStream;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f1 This is an alternative to setting ZipName.  This property allows you to create or modify an archive an a stream other than a file.
\par \f0 
\par The ArchiveStream property allows you to set the archive with a TStream\f1  (using D6, D7, or BCB6)\f0  or one of it's decendants\f1 , or a TkpStream (using D4, D5, BCB4, or BCB5) \f0 rather than setting the archive with a disk file using the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22 .  This lets you save archives in streams like database blob streams for instance or simply use faster in memory archives providing memory to memory compression and decompression.
\par You should use the ArchiveStream or the ZipName property but not both when specifying the zip archive.  
\par \f1 If you point ArchiveStream at a stream that you create, it is important to always retrieve your stream back from ArchiveStream.  Especially if you perform multiple operations on ArchiveStream.  Otherwise your original stream will not be correct.  So always do like this
\par :
\par \cf4\fs20    ArchiveStream := myStream; // set the ArchiveStream
\par    VCLZip.ReadZip;  // Do this only if myStream already holds an archive
\par    // Perform operations
\par    myStream := ArchiveStream; // retrieve it back.
\par    ArchiveStream := nil;   // Always nil out ArchiveStream
\par \f0 
\par \cf0\fs22 For an example of Stream to Stream zipping/unzipping \cf2\strike\f1 click here\cf3\strike0\f0{\v PG88}\cf0   
\par 
\par \cf1\b IMPORTANT:\cf0\b0  You should always free the ArhiveStream or whatever stream it points to yourself.  VCLZip will not try to free it.  You can create ArchiveStream and Free it directly such as...  
\par 
\par \pard\li360\cf4 VCLZip1.ArchiveStream := TMemoryStream.Create; 
\par ....  /* zip to myStream */ 
\par VCLZip1.ArchiveStream.Free; 
\par 
\par \pard\cf0 But more than likely \f1 you will want to use the stream afterwards. so you will probably want to retrieve the stream back from VCLZip...\f0   
\par 
\par \pard\li360\cf4\f1 var \f0 myStream : TMemoryStream; 
\par VCLZip1.ArchiveStream := \f1 TMemoryStream.Create\f0  
\par ... /* zip to myStream\f1 ...\f0  */ 
\par \f1 myStream := VCLZip.ArchiveStream;  // Get the stream for your use\f0 
\par VCLZip1.ArchiveStream := nil; \f1  // detach from VCLZip.\f0 
\par ... /* use myStream \f1 ...\f0 */ 
\par myStream.Free; \f1  // Free your stream when done
\par \f0 
\par \pard\cf0 Setting the ArchiveStream property will also cause the \strike KeepZipOpen Property\strike0\fs24{\v Scribble2460}\fs22  to be set to True so that the TStream will not be Free'd in between operations.  
\par ArchiveStream can be a new archive (set it using a new empty stream) or it can be an existing archive.  
\par As an example of creating a new archive in memory using a TStream:  
\par 
\par \cf4 With VCLZip1 do 
\par \pard\li120 begin 
\par \pard\li480\tx4800 ArchiveStream := TMemoryStream.Create;\tab /* Create archive in a memory stream */ 
\par FilesList.Add('c:\\mydir\\*.*');\tab /* zip all file in directory */ 
\par Zip;\tab /* this zips files into an archive in ArchiveStream, a memory stream */ 
\par \pard\li120 end; 
\par \cf0 
\par \pard Remember, if you want to save the archive that you have created in the ArchiveStream, you will have to save the ArchiveStream to a file yourself.  While you are working with ArchiveStream do not also reference ZipName since a memory stream does not have a filename ofcourse. 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2315}
{\up $}{\footnote {\up $} BlockMode property}
{\up +}{\footnote {\up +} vclunzip:000030}
{\up K}{\footnote {\up K} BlockMode;}
{\up A}{\footnote {\up A} TVCLUnZip_BlockMode;BlockMode_Property;BlockMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 BlockMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  BlockMode: \cf2\f2 TBlockMode\cf0  \f3 = (bmStandard, bmClassic);
\par 
\par \f7 
\par \b\fs22 Description
\par 
\par \pard\b0\f6\fs24 This affects how filenames are created by the Default \cf2\strike OnFileNameForSplitPart \cf3\strike0{\v Scribble2750}\cf0  event.  The default is \cf4 bmStandard\cf0  which creates filenames according to the PKZip standard.  \cf4 bmClassic\cf0  creates filenames compatible with the way previous versions of VCLZip created split archives.
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2320}
{\up $}{\footnote {\up $} BufferedStreamSize property}
{\up +}{\footnote {\up +} vclunzip:000040}
{\up K}{\footnote {\up K} BufferedStreamSize;}
{\up A}{\footnote {\up A} TVCLUnZip_BufferedStreamSize;BufferedStreamSize_Property;BufferedStreamSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 BufferedStreamSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  BufferedStreamSize: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 BufferedStreamSize is the size of the buffer that the Buffered File Stream uses.  By default, all files that VCLZip opens are buffered.  If you have NOSTREAMBUFF defined then this propery has no effect.  This has it's biggest effect on the speed that zip files are written to floppy or other slow media.  The default value for this property is \cf4 $8000\cf0   (32k) 
\par 
\par \f1 To increase the speed when writing to floppy disk you may want to try setting this value to \cf4\f0 $20000\cf0  (128k)\f1 .\f0  
\par The default should be good for your average zipping and unzipping, but you may tweak th\f1 is\f0  to best suit your application.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2325}
{\up $}{\footnote {\up $} BufferLength property}
{\up +}{\footnote {\up +} vclunzip:000050}
{\up K}{\footnote {\up K} BufferLength;}
{\up A}{\footnote {\up A} TVCLUnZip_BufferLength;BufferLength_Property;BufferLength}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 BufferLength property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  BufferLength: LongInt;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setting BufferLength to some value greater than zero, allows buffered output when unzipping directly to memory. Setting this property before calling either of the UnZipToBuffer methods...  
\par 
\par \strike UnZipToBuffer\strike0\fs24{\v Scribble2650}\fs22  
\par \strike UnZipToBufferByIndex\strike0\fs24{\v Scribble2655}\fs22  
\par 
\par to some value less than the total uncompressed size of the file being extracted will cause the \strike OnGetNextBuffer Event\strike0\fs24{\v Scribble2500}\fs22  event to be called every time BufferLength bytes have been unzipped. 
\par  
\par This can be useful also if you wish to preview what is in a large file without unzipping the entire file.  Or if you wish to be able to see a large file in an editor before the entire file is opened up into it.  
\par As an example, the following will unzip a file into a string buffer.  BufferLength is set to 1/4th of the length of the string buffer in order to show how \strike OnGetNextBuffer\strike0\fs24{\v Scribble2500}\fs22  gets called:
\par   
\par \cf4\f8 var 
\par \pard\li480 sBuffer, CurrentFile: String; 
\par tempPointer: pChar; 
\par n: Integer; 
\par \pard begin 
\par \pard\fi-6960\li6960\tx6960\tx720     n := FileDialog.FileBox.ItemIndex;\tab  \f9   \f8 /* Get index number of file to be unzipped */ 
\par \pard\fi-6960\li7440\tx7440\tx720 CurrentFile := LowerCase(FileDialog.SelectedFile.Text);\tab /* Get the filename to be unzipped */ 
\par SetLength(sBuffer, Zipper.UnCompressedSize[n]);\tab /* Set string length to uncompressed size of the file */ 
\par tempPointer := @sBuffer[1];\tab /* PChar pointer to begining of string */ 
\par Zipper.BufferLength := Length(sBuffer) div 4;\tab /* Set the BufferLength */ 
\par Zipper.UnZipToBuffer(tempPointer, CurrentFile );\tab /* Unzip the file into the string */ 
\par TextMemo.Lines.Text := sBuffer;\tab /* Point a textmemo at it so you can see it */ 
\par \pard\fi-6960\li6960\tx6960 end; 
\par \pard\cf0   
\par /* The OnGetNextBuffer event */ 
\par procedure TForm1.ZipperGetNextBuffer(Sender: TObject; var Buffer: PChar; FName: String; AmountUsed, BufferNum: Integer; var Quit: Boolean); 
\par begin 
\par \pard\li240 Buffer := Buffer + AmountUsed;  /* Slide the buffer pointer to the end of what has already been unzipped /* 
\par \pard end; 
\par 
\par \f0 Notice how the buffer pointer is slid along the string so that the next output from VCLZip will be appended to the end of what has already been unzipped.  You can also leave the pointer at the same position if you wish to use the same buffer over and over again.  You might use this technique if you simply copy the output from the buffer each time the OnGetNextBuffer event is called.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2330}
{\up $}{\footnote {\up $} Busy property}
{\up +}{\footnote {\up +} vclunzip:000060}
{\up K}{\footnote {\up K} Busy;}
{\up A}{\footnote {\up A} TVCLUnZip_Busy;Busy_Property;Busy}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Busy property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Busy: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Busy property will be True during any UnZip or Zip operations.  Checking this will allow you to start an operation, go on and do something else while the operation is executing in the background.  If you write your application in this way, check to be sure this property is False before beginning another operation.  
\par 
\par \cf1 IMPORTANT:\cf0   Do not try to modify any of VCLZip or VCLUnZip's properties while the Busy property is True.  You may do some background processing, but don't try to modify any properties during this time since those properties are still being used by the component.  
\par 
\par In order for this property to have any meaning when True, the \strike DoProcessMessages Property\strike0\fs24{\v Scribble2390}\fs22  should be set to True also.  Otherwise the Zip or UnZip operation won't relinquish control of the CPU for you to do other things.  
\par  \fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2335}
{\up $}{\footnote {\up $} CheckDiskLabels property}
{\up +}{\footnote {\up +} vclunzip:000070}
{\up K}{\footnote {\up K} CheckDiskLabels;}
{\up A}{\footnote {\up A} TVCLUnZip_CheckDiskLabels;CheckDiskLabels_Property;CheckDiskLabels}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CheckDiskLabels property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  CheckDiskLabels: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If set to \b True\b0 , the VCLUnZip component will check volume labels on \strike Spanned Disk Sets\strike0{\v PG700} each time a new disk is inserted.  If the volume label does not match the disk number that is requested, the request will be repeated until the proper disk is inserted.  
\par 
\par If set to \b False\b0 , the volume labels will be ignored.  It will then be up to you to be sure the correct disk is inserted.  Also note that if a spanned disk set was created by VCLZip while the \strike WriteDiskLabels\strike0{\v Scribble3140} property is False, then there will be no labels to check.  However, a spanned disk set that is expected to be read by PKZip, or another zip utility should have the labels.  
\par 
\par \cf1 IMPORTANT:\cf0  
\par This is a PUBLIC property in the VCLUnZip component, but it is a PUBLISHED subproperty of the \strike MultZipInfo Property\strike0{\v Scribble3280} in the VCLZip property.  
\par 
\par When only using the VCLUnZip component, set this property as follows...  
\par 
\par \pard\tx360\tab\cf4 UnZipper.CheckDiskLabels := True;\cf0   
\par 
\par \pard You may set this property in VCLZip the same way, or you may set it through the MultiZipInfo property, such as...  
\par 
\par \pard\tx360\tab\cf4 Zipper.MultiZipInfo.CheckDiskLabels := True;\cf0   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2340}
{\up $}{\footnote {\up $} CompressedSize property}
{\up +}{\footnote {\up +} vclunzip:000080}
{\up K}{\footnote {\up K} CompressedSize;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_CompressedSize;CompressedSize_Property;CompressedSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CompressedSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  CompressedSize[Index\f2 ]\f3 : Integer: BIGINT;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The CompressedSize property returns the compressed size of the file.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2345}
{\up $}{\footnote {\up $} CompressMethod property}
{\up +}{\footnote {\up +} vclunzip:000090}
{\up K}{\footnote {\up K} CompressMethod;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_CompressMethod;CompressMethod_Property;CompressMethod}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CompressMethod property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  CompressMethod[Index\f2 ]\f3 : Integer: WORD;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The CompressMethod property returns the compression method of the particular file. 
\par  
\par Be sure to include kpZipObj in your USES list if you plan on including any of the following in your application.  
\par Return value: 
\par  
\par \pard\li720 STORED =       0; 
\par SHRUNK =       1; 
\par REDUCED1 =   2; 
\par REDUCED2 =   3; 
\par REDUCED3 =   4; 
\par REDUCED4 =   5; 
\par IMPLODED =    6; 
\par TOKENIZED =   7; 
\par DEFLATED =    8;  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2350}
{\up $}{\footnote {\up $} CompressMethodStr property}
{\up +}{\footnote {\up +} vclunzip:000100}
{\up K}{\footnote {\up K} CompressMethodStr;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_CompressMethodStr;CompressMethodStr_Property;CompressMethodStr}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CompressMethodStr property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  CompressMethodStr[Index: Integer: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The CompressMethodStr property returns a string representation of the compression method for the particular file. The strings returned will be one of the following:  
\par 
\par \pard\li720\tx720 STORED =\tab 'STOR' 
\par SHRUNK =\tab 'SHR' 
\par REDUCED1 =\tab 'RED1' 
\par REDUCED2 =\tab 'RED2' 
\par REDUCED3 =\tab 'RED3' 
\par REDUCED4 =\tab 'RED4' 
\par IMPLODED =\tab 'IMP' 
\par TOKENIZED =\f1  \f0 'TOK' 
\par DEFLATED =\tab 'DEF'  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2355}
{\up $}{\footnote {\up $} Count property}
{\up +}{\footnote {\up +} vclunzip:000110}
{\up K}{\footnote {\up K} Count;}
{\up A}{\footnote {\up A} TVCLUnZip_Count;Count_Property;Count}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Count property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Count: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Count property returns the number of files in the Zip file.  \f1 The maximum is 2 gig.\f0 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2360}
{\up $}{\footnote {\up $} Crc property}
{\up +}{\footnote {\up +} vclunzip:000120}
{\up K}{\footnote {\up K} Crc;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_Crc;Crc_Property;Crc}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Crc property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Crc[Index\f2 ]\f3 : Integer: U_LONG;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Crc property returns the CRC for the particular file that is stored in the zipfile.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2365}
{\up $}{\footnote {\up $} DateTime property}
{\up +}{\footnote {\up +} vclunzip:000130}
{\up K}{\footnote {\up K} DateTime;Indexed Property;}
{\up A}{\footnote {\up A} TVCLUnZip_DateTime;DateTime_Property;DateTime}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DateTime property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DateTime[Index\f2 ]\f3 : Integer: TDateTime;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DateTime property returns the Date and Time stamp for the particular file in TDateTime format.  If using VCLZip you may also set this value to change the Date and Time stamp for a file in an existing archive.  
\par If you do set DateTime, the archive will be flagged as modified.  After setting all of the DateTime's that you wish to set, you should call the \strike SaveModifiedZipFile Method\strike0\fs24{\v Scribble3445}\fs22  to save the archive with the new DateTime's.  
\par 
\par \pard\li240 Reading DateTime: 
\par 
\par \pard\tx720\cf4\tab ThisTime := VCLZip.DateTime[i]; 
\par 
\par \pard\li240\cf0 Writing DateTime: 
\par 
\par \pard\li120\tx720\cf4\tab VCLZip.DateTime[i] := Now; 
\par \pard\li240\tx720\tab SaveModifiedZipFile; 
\par \pard\cf0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2370}
{\up $}{\footnote {\up $} DecryptHeader property}
{\up +}{\footnote {\up +} vclunzip:000140}
{\up K}{\footnote {\up K} DecryptHeader;Encryption;}
{\up A}{\footnote {\up A} TVCLUnZip_DecryptHeader;DecryptHeader_Property;DecryptHeader}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DecryptHeader property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DecryptHeader[Index\f2 ]\f3 : Integer: DecryptHeaderType;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DecryptHeader property will return the 12 byte decryption header for an encrypted file in an archive.  This is only useful for applications that wish to test the password for encrypted files in a more low level way.  Normally VCLZip will handle all of this for you internally.  
\par 
\par If you are developing in BCB you should use the \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  method instead.  
\par 
\par See Also:  
\par 
\par \strike Crc\strike0\fs24{\v Scribble2360}\fs22  
\par \strike Password\strike0\fs24{\v Scribble2550}\fs22  
\par \strike DecryptHeaderByte\strike0\fs24{\v Scribble2630}\fs22  
\par \strike GetDecryptHeaderByteByPtr\strike0\fs24{\v Scribble2635}\fs22  
\par \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2375}
{\up $}{\footnote {\up $} DestDir property}
{\up +}{\footnote {\up +} vclunzip:000150}
{\up K}{\footnote {\up K} DestDir;}
{\up A}{\footnote {\up A} TVCLUnZip_DestDir;DestDir_Property;DestDir}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DestDir property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DestDir: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DestDir property is  the path to where files will be extracted. If the path does not exist it will be created even if several levels of directories must be created.  In other words if DestDir is set to c:\\dir1\\dir2\\dir3 and only c:\\dir1 exists, dir2 and dir3 will be created.  It does not matter whether you include a '\\' at the end.
\par   
\par If DestDir is set to a '?' then a directory finder dialog box will be displayed so that a directory can be selected. If you set DestDir to '?' and the user presses the cancel button on the dialog box, a EUserCanceled exception will be thrown and DestDir, along with all other properties will remain unchanged  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2380}
{\up $}{\footnote {\up $} DiskNo property}
{\up +}{\footnote {\up +} vclunzip:000160}
{\up K}{\footnote {\up K} DiskNo;Indexed Properties;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_DiskNo;DiskNo_Property;DiskNo}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DiskNo property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DiskNo[Index: Integer: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DiskNo property returns the disk number of the specified file.  This is useful when working with multi-file zip files (DISK SPANNING).  The first file/disk in a multifile set is #1.  For single file zip files this will always return a 1, but for multi-file zip files it will return the actual disk that the compressed file begins on.  \f1  The maximum for VCLZip Lite is 65535 while the maximum for VCLZip Pro is 2 gig.
\par \f0 
\par See Also: 
\par  
\par \strike Creating Spanned Disk Zip Files\strike0\fs24{\v PG700}\fs22  
\par \strike Creating Blocked Zip Files\strike0\fs24{\v PG2}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2385}
{\up $}{\footnote {\up $} DoAll property}
{\up +}{\footnote {\up +} vclunzip:000170}
{\up K}{\footnote {\up K} DoAll;UnZip;}
{\up A}{\footnote {\up A} TVCLUnZip_DoAll;DoAll_Property;DoAll}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DoAll property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DoAll: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The \f1 DoAll\f0  property, if set to True\f1 , will cause all files to be unzipped when the \cf2\strike UnZip method\cf3\strike0{\v Scribble2640}\cf0  is called even without putting anything into the \cf2\strike FilesList\cf3\strike0{\v Scribble2425}\cf0 .\f0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2390}
{\up $}{\footnote {\up $} DoProcessMessages property}
{\up +}{\footnote {\up +} vclunzip:000180}
{\up K}{\footnote {\up K} DoProcessMessages;}
{\up A}{\footnote {\up A} TVCLUnZip_DoProcessMessages;DoProcessMessages_Property;DoProcessMessages}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DoProcessMessages property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DoProcessMessages: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DoProcessMessages property determines whether a call to Application.ProcessMessages will be called periodically during operations.  Setting this to true will allow you to cancel long operations by calling the \strike CancelTheOperation Method\strike0\fs24{\v Scribble2675}\fs22 . It will also allow things like screen repaints and such.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2395}
{\up $}{\footnote {\up $} EncryptBeforeCompress property}
{\up +}{\footnote {\up +} vclunzip:000190}
{\up K}{\footnote {\up K} EncryptBeforeCompress;Encryption;Password;}
{\up A}{\footnote {\up A} TVCLUnZip_EncryptBeforeCompress;EncryptBeforeCompress_Property;EncryptBeforeCompress}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 EncryptBeforeCompress property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  EncryptBeforeCompress: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set this property to True if you want VCLZip to perform encryption on data BEFORE compressing it. The normal pkzip process is to compress the data and then encrypt it.  This will perform encryption directly on the original data
\par .  
\par However, this feature is not that useful\f1 , \f0 because \f1 encryption \f0 actually renders the data un-compressable because it randomizes the data. Often, small un-compressable files will be STORE'd insteand of DEFLATED in the archive. Since, in this case, there is no compression, EncryptBeforeCompression is irrelevant. Therefore, this property is most useful when used with your own encryption technique (see OnEncrypt and OnDecrypt above) as long as it does not randomize the data too much. 
\par  
\par Note that if you create a zip file with encrypted files while this is set to True, the property must also be set to True when decompressing the same data.  
\par 
\par See Also: 
\par  
\par \strike OnEncrypt\strike0\fs24{\v Scribble3465}\fs22  
\par \strike OnDecrypt\strike0\fs24{\v Scribble2740}\fs22  
\par \strike Password\strike0\fs24{\v Scribble2550}
\par \fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2400}
{\up $}{\footnote {\up $} ExternalFileAttributes property}
{\up +}{\footnote {\up +} vclunzip:000200}
{\up K}{\footnote {\up K} ExternalFileAttributes;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_ExternalFileAttributes;ExternalFileAttributes_Property;ExternalFileAttributes}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ExternalFileAttributes property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ExternalFileAttributes[Index\f2 ]\f3 : Integer: U_LONG;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ExternalFileAttributes property contains the MSDOS file attributes in the low order byte.  You can read this using the file attribute constants faReadOnly, faDirectory, faArchive, faHidden, faSysFile, and faVolumeID.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2405}
{\up $}{\footnote {\up $} FileComment property}
{\up +}{\footnote {\up +} vclunzip:000210}
{\up K}{\footnote {\up K} Comments;FileComment;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_FileComment;FileComment_Property;FileComment}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FileComment property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FileComment[Index\f2 ]\f3 : Integer: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FileComment property returns the comment for the specified file, if there is one. For 16 bit (Delphi 1) no more than 255 characters of the comment are returned.  
\par 
\par When using the TVCLZip component, you can also assign a comment to the specified file.
\par   
\par See Also:  
\par 
\par \strike FileHasComment\strike0\fs24{\v Scribble2410}\fs22  
\par \strike ZipComment\strike0\fs24{\v Scribble2605}\fs22  
\par \strike SaveModifiedZipFile Method\strike0\fs24{\v Scribble3445}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2410}
{\up $}{\footnote {\up $} FileHasComment property}
{\up +}{\footnote {\up +} vclunzip:000220}
{\up K}{\footnote {\up K} Comments;FileComment;FileHasComment;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_FileHasComment;FileHasComment_Property;FileHasComment}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FileHasComment property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FileHasComment[Index: Integer: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FileComment property returns the comment for the specified file, if there is one. For 16 bit (Delphi 1) no more than 255 characters of the comment are returned.  
\par 
\par When using the TVCLZip component, you can also assign a comment to the specified file.  
\par 
\par See Also:  
\par 
\par \strike FileHasComment\strike0\fs24{\v Scribble2410}\fs22  
\par \strike ZipComment\strike0\fs24{\v Scribble2605}\fs22  
\par \strike SaveModifiedZipFile Method\strike0\fs24{\v Scribble3445}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2415}
{\up $}{\footnote {\up $} FileIsOK property}
{\up +}{\footnote {\up +} vclunzip:000230}
{\up K}{\footnote {\up K} FileIsOK;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_FileIsOK;FileIsOK_Property;FileIsOK}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FileIsOK property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FileIsOK[Index\f2 ]\f3 : Integer: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This property tests for the integrity of individual files within an archive.  
\par 
\par If FileIsOK[Index] is False then that particular file within the archive is probably corrupted.  When this property is first checked, the compressed file is run through a test unzip procedure, exactly as if it was being unzipped except that nothing is actually written out to any file.  If there are any exceptions or errors during the unzip process, the result for this property will be False. Any time you test this property after the first time, while you still have the archive open, it will return the same result, without having to go through the unzipping process (the result is remembered).  However, there is a method called \cf4 ResetFileIsOK(Index)\cf0  which you may use to reset this property for a particular compressed file.  
\par 
\par If you use this property for a password protected file, be sure to set the password property first, or those password protected files will be reported as being possibly corrupt.  
\par 
\par \cf1 IMPORTANT: \cf0  Be sure the \strike DoAll Property\strike0\fs24{\v Scribble2385}\fs22  is set to False when using this property.  If DoAll is set to True then VCLZip will try to process all of the files in the archive and  
\par 
\par \cf1 NOTE:\cf0  If you run the \strike FixZip Method\strike0\fs24{\v Scribble3390}\fs22  on an archive that contains any files that test as being corrupted, those files will not be included in the fixed version of the archive.  
\par 
\par If you wish to test the integrity of an entire archive, and the archive has MANY files in it, you should use the \strike CheckArchive\strike0\fs24{\v Scribble2625}\fs22  procedure. If you have many files in the archive you will find that it will be much faster than using the FileIsOK property.  
\par 
\par However, if you wish to test the integrity of an entire archive that does not have MANY files in it, an easy way that would not require an OnBadCRC event would be:  
\par 
\par \cf4\f8 procedure TVCLZipForm.TestZipFilesClick(Sender: TObject); 
\par var 
\par \pard\li240 i: Integer; 
\par \pard begin 
\par \pard\li240 InfoWin.Lines.Add('Beginning integrity test for ' + IntToStr(Zipper.Count) + ' files for ' + Zipper.ZipName); 
\par For i := 0 to Zipper.Count-1 do 
\par \pard\li360 begin 
\par \pard\li600 if (Zipper.FileIsOK[i]) then 
\par \pard\li960 InfoWin.Lines.Add( Zipper.FullName[i] + ' is OK.' ) 
\par \pard\li600 else 
\par \pard\li960 InfoWin.Lines.Add( Zipper.FullName[i] + ' may be corrupt.' ); 
\par \pard\li360 end; 
\par Gauge1.Progress := 0; 
\par Gauge2.Progress := 0; 
\par \pard end; 
\par \cf0\f0 
\par See Also: 
\par  
\par \pard\li240\strike CheckArchive\strike0\fs24{\v Scribble2625}\fs22  
\par \strike FixZip\strike0\fs24{\v Scribble3390}\fs22  
\par \pard  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2420}
{\up $}{\footnote {\up $} Filename property}
{\up +}{\footnote {\up +} vclunzip:000240}
{\up K}{\footnote {\up K} Filename;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_Filename;Filename_Property;Filename}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Filename property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Filename[Index\f2 ]\f3 : Integer: TZipFilename;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Filename property returns just the filename portion of the file, without the path. TZipFilename type is just a String type.  
\par 
\par If you are using VCLZip, this property is also writable.   Once you have opened up a zip file you may set this property, thereby modifying what is already contained by this property.  It is up to you to be sure not to modify this in such a way that you would end up with two files in the zip archive with the same Filename and Pathname.  
\par 
\par If you do set Filename, the archive will be flagged as modified.  After setting all of the Filenames that you wish to set, you should call the \strike SaveModifiedZipFile Method\strike0{\v Scribble3445} to save the archive with the new Filenames.  
\par 
\par \pard\li240 Reading Filename: 
\par 
\par \pard\tx720\cf4\tab ThisName := VCLZip.Filename[i];  
\par \cf0 
\par \pard\li240 Writing Filename: 
\par 
\par \pard\li120\tx720\cf4\tab VCLZip.Filename[i] := NewName; 
\par \pard\li240\tx720\tab SaveModifiedZipFile;  
\par \pard  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf0\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2425}
{\up $}{\footnote {\up $} FilesList property}
{\up +}{\footnote {\up +} vclunzip:000250}
{\up K}{\footnote {\up K} FilesList;Specifying Files;UnZip;Zip;}
{\up A}{\footnote {\up A} TVCLUnZip_FilesList;FilesList_Property;FilesList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FilesList property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FilesList: TStrings;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Add filenames and/or wildcard specifications to this file list to specify what files will be extracted, added, or deleted from/to the zipfile.  If the property \strike DoAll\strike0\fs24{\v Scribble2385}\fs22  is set to True when extracting (calling \strike UnZip\strike0\fs24{\v Scribble2640}\fs22 ) then the contents of this list will be ignored and all files will be extracted.  Also, if FilesList is empty when calling \strike UnZip\strike0\fs24{\v Scribble2640}\fs22  all files will be extracted, even if DoALL is not set to True.  
\par 
\par \strike Wildcards\strike0\fs24{\v PG18}\fs22  may be used when adding to the FilesList.  Also, it is possible to \strike override the Recurse\strike0\fs24{\v Scribble3335}\fs22  property by adding special characters at the beginning of any entry added to the FilesList.  See the \strike Recurse\strike0\fs24{\v Scribble3335}\fs22  property for more information.  
\par 
\par VCLZip clears the FilesList after any zip or unzip operation, so the FilesList will be empty when after a call to any of the zip or unzip methods.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2430}
{\up $}{\footnote {\up $} FlushFilesOnClose property}
{\up +}{\footnote {\up +} vclunzip:000260}
{\up K}{\footnote {\up K} FlushFilesOnClose;}
{\up A}{\footnote {\up A} TVCLUnZip_FlushFilesOnClose;FlushFilesOnClose_Property;FlushFilesOnClose}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FlushFilesOnClose property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FlushFilesOnClose: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 When set to True this property will cause all files that are open for write to have their disk buffers flushed when they are closed.  When the file is closed, the API call to FlushFileBuffers is made. 
\par  
\par This only has an effect ofcourse, on files opened for write and no effect on files opened for reading only.  So when unzipping, this would cause the disk buffers to be flushed for the files that have been extracted, and when zipping, this would cause the archive being created to have it's buffers flushed to disk when closed.  
\par 
\par This property has no effect at all, when in a Delphi 1 (16bit) environment or when you have \strike NOSTREAMBUFF\strike0\fs24{\v PG152}\fs22  defined.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2435}
{\up $}{\footnote {\up $} FullName property}
{\up +}{\footnote {\up +} vclunzip:000270}
{\up K}{\footnote {\up K} FullName;Indexed Properties;}
{\up A}{\footnote {\up A} TVCLUnZip_FullName;FullName_Property;FullName}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FullName property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FullName[Index\f2 ]\f3 : Integer: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FullName property returns the full path and filename of the file.  Same as  Pathname[Index] + '\\' + Filename[Index].  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2440}
{\up $}{\footnote {\up $} ImproperZip property}
{\up +}{\footnote {\up +} vclunzip:000280}
{\up K}{\footnote {\up K} ImproperZip;}
{\up A}{\footnote {\up A} TVCLUnZip_ImproperZip;ImproperZip_Property;ImproperZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ImproperZip property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ImproperZip: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 ImproperZip is a ReadOnly property.  The best place to check the value of this property is after a call to \strike ReadZip\strike0\fs24{\v Scribble10}\fs22 . If it has a value of True, then VCLZip detected that the zip file had something wrong with it's file structure and could possibly be corrupted.  If you did not get an exception thrown, VCLZip may have read the zip information ok, but it had to do it in a way that bypassed the problem and so it is not guaranteed that everything is ok.  
\par 
\par See Also:
\par   
\par \strike IncompleteZipMode Property\strike0\fs24{\v Scribble2445}\fs22  
\par \strike OnInCompleteZip Event\strike0\fs24{\v Scribble2510}\fs22  
\par \strike CheckArchive Method\strike0\fs24{\v Scribble2625}\fs22  
\par \strike FileIsOK Property\strike0\fs24{\v Scribble2415}\fs22   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2445}
{\up $}{\footnote {\up $} IncompleteZipMode property}
{\up +}{\footnote {\up +} vclunzip:000290}
{\up K}{\footnote {\up K} IncompleteZipMode;Search Attribute;}
{\up A}{\footnote {\up A} TVCLUnZip_IncompleteZipMode;IncompleteZipMode_Property;IncompleteZipMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IncompleteZipMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IncompleteZipMode: TIncompleteZipMode = (izAssumeMulti, izAssumeBad, izAssumeNotAZip);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The IncompleteZipMode property determines how VCLZip will behave when a file that does not have an End Of Central Directory header is encountered.  This would mean one of the three following possibilities:  
\par 
\par \pard\li600 1. This is part of a multi-file zipfile and it is not the last file/disk in the set. 
\par 2. It is a bad zip file - corrupted or truncated 
\par 3. The file is not a zip file 
\par 
\par \pard How VCLZip behaves depends also on whether or not you have defined an OnIncompleteZip event.  
\par See the \strike OnInCompleteZip Event\strike0\fs24{\v Scribble2510}\fs22  for complete details.  
\par  
\par \fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2450}
{\up $}{\footnote {\up $} IsEncrypted property}
{\up +}{\footnote {\up +} encryption:000030}
{\up K}{\footnote {\up K} Encryption;IsEncrypted;Password;}
{\up A}{\footnote {\up A} TVCLUnZip_IsEncrypted;IsEncrypted_Property;IsEncrypted}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IsEncrypted property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IsEncrypted[Index: Integer: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The IsEncrypted property returns True if the compressed file is password encrypted.  
\par 
\par See Also: 
\par  
\par \strike Password\strike0\fs24{\v Scribble2550}\fs22  
\par \strike OnBadPassword Event\strike0\fs24{\v Scribble2490}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2455}
{\up $}{\footnote {\up $} isZip64 property}
{\up +}{\footnote {\up +} vclunzip:000300}
{\up K}{\footnote {\up K} isZip64;Zip64;}
{\up A}{\footnote {\up A} TVCLUnZip_isZip64;isZip64_Property;isZip64}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 isZip64 property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  isZip64: Boolean;
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \f6 This property is true if the archive has reached one of the size/number limits of the normal pkzip format which means that the archive would then begin implementing Zip64 fomatting.  When this is True, only zip utilities that can handle the Zip64 format will be able to work with the archive.  When it is False, normal zip utilities will be able to work with the archive.
\par 
\par The limits of normal PKZip format is 4 gig for file and archive sizes and 65535 for the number of files compressed into an archive.\f7 
\par 
\par \fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2460}
{\up $}{\footnote {\up $} KeepZipOpen property}
{\up +}{\footnote {\up +} vclunzip:000310}
{\up K}{\footnote {\up K} KeepZipOpen;}
{\up A}{\footnote {\up A} TVCLUnZip_KeepZipOpen;KeepZipOpen_Property;KeepZipOpen}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 KeepZipOpen property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  KeepZipOpen: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Normally the zip file specified by ZipName is not kept open between operations.  By setting this property to True the file will remain open until you either call the \strike ClearZip Method\strike0\fs24{\v Scribble2685}\fs22  or until you open another file.  This may improve performance if you plan to do a lot of operations on a particular file, for instance you may need to perform several separate unzips, unzipping one file at a time rather than just filling the \strike FilesList Property\strike0\fs24{\v Scribble2705}\fs22  with all filenames you wish to unzip.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2465}
{\up $}{\footnote {\up $} MultiMode property}
{\up +}{\footnote {\up +} vclunzip:000320}
{\up K}{\footnote {\up K} MultiMode;}
{\up A}{\footnote {\up A} TVCLUnZip_MultiMode;MultiMode_Property;MultiMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 MultiMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  MultiMode: TMultiMode;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 In TVCLUnZip and TVCLZip: 
\par \b\f8 property\b0  MultiMode : TMultiMode  
\par In TVCLZip: 
\par \b property\b0  MultiZipInfo.MultiMode : TMultiMode  
\par TMultiMode = (mmNone, mmSpan, mmBlocks);  
\par 
\par \b\f0 Description  
\par \b0 The MultiMode property determines whether a multi-part zip file will be created as several files on the same disk or a a zip file that actually spans physical disks.  
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\ul\b Value\ulnone\tab\ul Meaning\ulnone\b0   
\par mmNone\tab Normal zip files  
\par mmSpan\tab Zip file will physically span disks (if large enough)  
\par mmBlocks\tab Zip file will be broken into separate files (blocks) on the same disk (typically to be copied to separate disks later).  
\par \pard   
\par When using the VCLUnZip component you should set this property as follows:  
\par 
\par \pard\tx360\tab\cf4 UnZipper.MultiMode := mmNone;\cf0   
\par 
\par \pard When using the VCLZip component, you may set or read this property the same way, or you may access it through the \strike MultZipInfo Property\strike0{\v Scribble3280} as follows:  
\par 
\par \pard\tx360\tab\cf4 Zipper.MultiZipInfo.MultiMode := mmBlocks;\cf0   
\par 
\par \pard When opening a zip file, (that is after calling the \strike ReadZip Method\strike0{\v Scribble2720}) if a multi-file zip file is detected, this property is automatically set according to what type of media the zip file is on.  If the zip file is on a \b REMOVABLE\b0  disk, the multi-file zip is considered to be a \strike Spanned Disk Set\strike0{\v Scribble3280} with each file residing on a separate removable disk.  Therefore the MultiMode property is set to \cf4 mmSpan\cf0 .  If, however, the zip file is \b NOT\b0  on a \b REMOVABLE\b0  disk, it is considered to be a \strike Blocked Zip File\strike0{\v PG2} and this property is set to \cf4 mmBlocks\cf0 .  
\par After opening the zip file, you may modify this property if the automatic detection is not correct.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2470}
{\up $}{\footnote {\up $} NumDisks property}
{\up +}{\footnote {\up +} vclunzip:000330}
{\up K}{\footnote {\up K} NumDisks;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_NumDisks;NumDisks_Property;NumDisks}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 NumDisks property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  NumDisks: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The NumDisks property returns the number of parts to the zip file.  Normally this will return 1, but if you are working with a spanned disk set or a multipart file, this will return the actual number of disks or parts.  \f1 The maximum for VCLZip Lite is 65,535 while the maxiumum for VCLZip Pro is 2 gig.\f0 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2475}
{\up $}{\footnote {\up $} NumSelected property}
{\up +}{\footnote {\up +} vclunzip:000340}
{\up K}{\footnote {\up K} NumSelected;}
{\up A}{\footnote {\up A} TVCLUnZip_NumSelected;NumSelected_Property;NumSelected}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 NumSelected property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  NumSelected: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 NumSelected reflects the number of compressed files that have been selected with the \strike Selected\strike0\fs24{\v Scribble2585}\fs22  property.  
\par 
\par After an unzip operation this number will be zero as all selections will be cleared. 
\par  
\par See Also:  
\par 
\par \strike Selected\strike0\fs24{\v Scribble2585}\fs22  
\par \strike ClearSelected\strike0\fs24{\v Scribble2680}\fs22  
\par \strike UnZipSelected\strike0\fs24{\v Scribble2645}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2480}
{\up $}{\footnote {\up $} OEMConvert property}
{\up +}{\footnote {\up +} vclunzip:000350}
{\up K}{\footnote {\up K} OEMConvert;}
{\up A}{\footnote {\up A} TVCLUnZip_OEMConvert;OEMConvert_Property;OEMConvert}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OEMConvert property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OEMConvert: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Historically pkzip data has been run through an OEM conversion to make it ascii compatible, thereby losing accented characters.  Nowdays this is becoming less prevelant.  Setting this to false will eliminate all OEM conversions and leave the data as is.  The default value for this property is true for backward compatability.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2485}
{\up $}{\footnote {\up $} OnBadCRC Event}
{\up +}{\footnote {\up +} vclunzip:000360}
{\up K}{\footnote {\up K} Events;OnBadCRC;}
{\up A}{\footnote {\up A} TVCLUnZip_OnBadCRC;OnBadCRC_Event;OnBadCRC}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnBadCRC Event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnBadCRC: \cf2 TBadCRC\cf0\f2  \f3 = \b procedure\b0 (Sender: TObject; CalcCRC, StoredCRC: LongInt; FileIndex: Integer); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnBadCRC event handler is triggered when the value for the CRC for a file just extracted does not match the CRC that was calculated by the TVCLUnZip component.   The values for the calculated CRC and the stored CRC are passed in the CalcCRC and StoredCRC variables respectively.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2490}
{\up $}{\footnote {\up $} OnBadPassword Event }
{\up +}{\footnote {\up +} encryption:000040}
{\up K}{\footnote {\up K} Encryption;Events;OnBadPassword;Password;}
{\up A}{\footnote {\up A} TVCLUnZip_OnBadPassword;OnBadPassword_Property;OnBadPassword}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnBadPassword Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnBadPassword: \cf2 TBadPassword\cf0\f2  \f3 = \b procedure\b0 (Sender: TObject; FileIndex: Integer; \b var\b0  NewPassword: \b string\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnBadPassword event handler is triggered whenever an attempt is made to extract an encrypted file with an incorrect password.  If you wish to RETRY with a new password, then set NewPassword to the desired password.  If you do not set NewPassword to a new password then the file will be skipped, possibly also resulting in a call to the \strike OnSkippingFile Event\strike0\fs24{\v Scribble2520}\fs22 .  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \b\f6\fs24 See Also:\f7\fs16 
\par \pard\b0\strike\f1\fs22 EncryptionStrength\f0  \f1 Property\strike0\f0\fs24{\v Scribble2553}\fs22  
\par \strike\f1 Pass\f0 word \f1 Property\strike0\f0\fs24{\v Scribble2550}\fs22  
\par \strike OnBadPassword Event\strike0\fs24{\v Scribble2490}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\strike IsEncrypted property\cf3\strike0{\v Scribble2450}\cf0 
\par 
\par \f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2495}
{\up $}{\footnote {\up $} OnFilePercentDone Event }
{\up +}{\footnote {\up +} vclunzip:000370}
{\up K}{\footnote {\up K} Events;OnFilePercentDone;Progress;}
{\up A}{\footnote {\up A} TVCLUnZip_OnFilePercentDone;OnFilePercentDone_Event;OnFilePercentDone}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnFilePercentDone Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnFilePercentDone: \cf2 TFilePercentDone\cf0  = \b procedure\b0 (Sender: TObject; Percent: LongInt); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnFilePercentDone event handler is Triggered periodically to report the progress on the current file being processed.  Percent represents a percentage between 1 and 100.
\par 
\par \f1 This event will be called not only during zipping and unzipping, but also while writing/saving files from an original zip file when modifiying an existing zip file.  One tip here is to set a flag in the \cf2\strike OnStartZipInfo\cf3\strike0{\v Scribble2525}\cf0  event\f0  \f1 so that you know which situation this event is being called.  Anything before the OnStartZipInfo event is a result of moving original files while anything after OnStartZipInfo will be a result of actual compression.
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2500}
{\up $}{\footnote {\up $} OnGetNextBuffer Event }
{\up +}{\footnote {\up +} vclunzip:000380}
{\up K}{\footnote {\up K} Events;OnGetNextBuffer;}
{\up A}{\footnote {\up A} TVCLUnZip_OnGetNextBuffer;OnGetNextBuffer_Event;OnGetNextBuffer}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnGetNextBuffer Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnGetNextBuffer: \cf2 TGetNextBuffer\cf0  = \b procedure\b0 (Sender: TObject; \b var\b0  Buffer: PChar; FName: \b string\b0 ; AmountUsed: LongInt; BufferNum: Integer; \b var\b0  Quit: Boolean); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Before this event can be called, \strike BufferLength\strike0\fs24{\v Scribble2325}\fs22  must be set to a value greater than zero.  
\par When unzipping to a memory buffer, if your \strike BufferLength\strike0\fs24{\v Scribble2325}\fs22  is smaller than the uncompressed size of the file being processed, this event will be called to:  
\par 
\par 1. Pass you the buffer that was just processed in the \b Buffer\b0  parameter so that you may do whatever you need to do with it.  The \b AmountUsed\b0  parameter will contain the amount of bytes that were written to the buffer.  AmountUsed will typically be the same as BufferLength except for the end of the file which may not fill up the buffer. 
\par  
\par 2. Allow you to pass back a new buffer pointer, also in the \b Buffer\b0  parameter.  You don't have to change the Buffer pointer if you wish the same buffer to be used again.  If you wish to change the length of the buffer you can by resetting the \b BufferLength\b0  property to a new value. 
\par  
\par Also passed to you by this event are:  
\par 
\par \pard\fi-1440\li1440\tx1440\tx720\b FName\b0\tab The name of the file associated with the processing of this buffer at this time.  
\par \b BufferNum\b0\tab The sequential number of this buffer being passed in for this file.  The first buffer is number 1.  
\par \b Quit\b0\tab If this is passed to you as True then this is the last buffer to be processed for this file.  You may also set this to True at any time to stop processing on the current file.  If you do this then a \b EUserCanceled\b0  exception will be thrown that you may wish to trap.  
\par \pard   
\par For an example see  \strike BufferLength\strike0\fs24{\v Scribble2325}\fs22 .  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2505}
{\up $}{\footnote {\up $} OnGetNextDisk Event }
{\up +}{\footnote {\up +} vclunzip:000390}
{\up K}{\footnote {\up K} Events;OnGetNextDisk;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_OnGetNextDisk;OnGetNextDisk_Event;OnGetNextDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnGetNextDisk Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnGetNextDisk: \cf2 TGetNextDisk\cf0  = \b procedure\b0 (Sender: TObject; NextDisk: Integer; \b var\b0  FName: \b string\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\cf1\b0\f0 NOTE:\cf0  If you do not define this event then \f1 Default\f0 GetNextDisk is \f1 called internally and\f0  will handle both zipping and unzipping cases\f1  for you\f0 .  
\par 
\par \cf4\b When Unzipping:\cf0\b0   
\par When unzipping from a multi-part zip file this event is triggered when a file that is about to be unzipped is on a different disk from the one that is currently in the drive. NextDisk will tell you the disk number of the multi-part zipfile that should be inserted. The first disk in a disk set is number 1. 
\par  
\par If you are working with a \f1 blocked archive \f0 (\f1 multiple files spanned directly to hard drive\f0 ) then you should \f1 work with the \cf2\strike OnFileNameForSplitPart event\cf3\strike0{\v Scribble2750}\cf0  instead.
\par \f0 
\par If you have set the \strike CheckDiskLabels Property\strike0\fs24{\v Scribble2335}\fs22  to True, then the volume label will be checked for the newly inserted diskette to be sure it is for the next disk in the spanned zip file.  Normal spanned zip files have volume labels like 'PKBACK 001', 'PKBACK 002', etc.  So if the current disk is disk 1, and you have CheckDiskLabels set to True, then OnGetNextDisk will repeat until the correct diskette has been inserted.  
\par 
\par \cf4\b When Zipping:\cf0\b0   
\par When creating a new multi-part zip file, this event is triggered when the current diskette is full and you should remove it and insert a new diskette.  No checking is involved in this case since VCLZip can only assume you are inserting the disk that you want the next part on, so you may wish to check in some way in this event to be sure that the disk that has been inserted meets your satisfaction.  
\par 
\par If you wish to further prepare the diskette that has been inserted (for instance to format or delete currently existing files), you may put code to do so into the \strike OnPrepareNextDisk\strike0\fs24{\v Scribble3290}\fs22  event\f1  which is called right after this event\f0 .  
\par 
\par \cf1\ul\b\fs25 WARNING!\cf0\ulnone\b0\fs22   It is up to you to be sure the user inserted the correct disk.  Results of inserting the wrong disk are unknown and likely not good.  
\par 
\par See Also:  
\par 
\par \strike OnPrepareNextDisk\strike0\fs24{\v Scribble3290}\fs22   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2510}
{\up $}{\footnote {\up $} OnInCompleteZip Event }
{\up +}{\footnote {\up +} vclunzip:000400}
{\up K}{\footnote {\up K} Events;OnInCompleteZip;}
{\up A}{\footnote {\up A} TVCLUnZip_OnInCompleteZip;OnInCompleteZip_Event;OnInCompleteZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnInCompleteZip Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnInCompleteZip: \cf2 TInCompleteZip\cf0  = \b procedure\b0 (Sender: TObject; \b var\b0  IncompleteMode: TIncompleteZipMode); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnInCompleteZip event handler is triggered whenever the component cannot find an END CENTRAL DIRECTORY which means one of the following:  
\par 
\par \pard\li600 1. This is part of a multi-file zipfile and it is not the last file/disk in the set. 
\par 2. It is a bad zip file - corrupted or truncated 
\par 3. The file is not a zip file 
\par 
\par \pard If VCLZip encounters a file for which it cannot find an end central directory, the behavior depends upon two things:  
\par 
\par \pard\li120 1. How the \strike IncompleteZipMode Property\strike0\fs24{\v Scribble2445}\fs22  is set. 
\par 2. How you define what happens in the OnIncompleteZip event (if you have one defined that is).  
\par 
\par \pard You can set the value for the IncompleteZipMode property in the Object Inspector, anywhere in your code, or inside the OnIncompleteZip event, through the IncompleteMode paratmeter. 
\par  
\par \b >If no OnIncompleteZip event is defined:\b0   
\par If you do not have an OnIncompleteZip event defined, the following happens when VCLZip is presented with a file for which it can't find an end central directory: 
\par  
\par \pard\fi-3000\li3000\tx3000\tx720\ul\b IncompleteZipMode Value\ulnone\tab\ul Action\ulnone   
\par \b0 izAssumeMulti\tab An \cf4 EIncompleteZip exception\cf0  is thrown. 
\par izAssumeBad\tab An attempt is made to read as much of the zip file as possible using the local headers.  The results of this can be unpredictable.  If it still can't detect any files in the archive, then an \cf4 EBadZipFile exception\cf0  is thrown. 
\par izAssumeNotAZip\tab An \cf4 ENotAZipFile exception\cf0  is thrown. 
\par \pard   
\par It is up to your program to trap these exceptions and handle them as you see fit. 
\par  
\par \b >If there IS an OnIncompleteZip event defined:\b0   
\par When no end of central directory is found:  
\par 1) The OnIncompleteZip event is called. 
\par 2) You have the opportunity to set the IncompleteZipMode property here through the IncompleteMode parameter.  
\par 
\par VCLZip's behavior depends on how you set the IncompleteZipMode property.  
\par 
\par \pard\fi-3000\li3000\tx3000\tx720\ul\b IncompleteZipMode Value\ulnone\tab\ul Action\ulnone   
\par \b0 izAssumeMulti\tab Another attempt will be made to read the zip file.  It is assumed in this case that you prompted the user for the last disk in a spanned disk set. 
\par izAssumeBad\tab An attempt is made to read as much of the zip file as possible using the local headers.  The results of this can be unpredictable.  If it still can't read it, then an \cf4 EBadZipFile exception\cf0  is thrown. 
\par izAssumeNotAZip\tab An \cf4 ENotAZipFile exception\cf0  exception is thrown. 
\par \pard   
\par Again, it is up to your program to trap these exceptions.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2515}
{\up $}{\footnote {\up $} OnPromptForOverwrite Event }
{\up +}{\footnote {\up +} vclunzip:000410}
{\up K}{\footnote {\up K} Events;OnPromptForOverwrite;}
{\up A}{\footnote {\up A} TVCLUnZip_OnPromptForOverwrite;OnPromptForOverwrite_Event;OnPromptForOverwrite}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnPromptForOverwrite Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnPromptForOverwrite: \cf2 TPromptForOverwrite\cf0  = \b procedure\b0 (Sender: TObject; \b var\b0  OverWriteIt: Boolean; FileIndex: Integer; \b var\b0  FName: \b string\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnPromptForOverwrite event handler is triggered when the property OverwriteMode is set to Prompt and a file is about to be overwritten.  This gives you a chance to determine whether to overwrite or not.  Set OverWriteIt to True if you wish to overwrite the file, otherwise the file will not be overwritten. You also have the opportunity to rename the file that is about to be unzipped.  If you do this, you should also set OverwriteIt to True. 
\par  
\par If this event is not defined and the property OverwriteMode is set to Prompt then the TVCLUnZip component will display a messagebox to ask whether the file that is about to be overwritten, should be overwritten.  In this case you do not get a chance to rename the file.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2520}
{\up $}{\footnote {\up $} OnSkippingFile Event }
{\up +}{\footnote {\up +} vclunzip:000420}
{\up K}{\footnote {\up K} Events;OnSkippingFile;}
{\up A}{\footnote {\up A} TVCLUnZip_OnSkippingFile;OnSkippingFile_Event;OnSkippingFile}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnSkippingFile Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnSkippingFile: \cf2 TSkippingFile\cf0  = \b procedure\b0 (Sender: TObject; Reason: TSkipReason; FName: \b string\b0 ; FileIndex: Integer; \b var\b0  Retry: Boolean); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnSkippingFile event handler is Triggered when a file that would have otherwise been processed is being skipped. 
\par  
\par The reason for the file being skipped is in the \cf4 Reason\cf0  argument. 
\par  
\par \cf4 FName\cf0  is name of the file being skipped.  
\par 
\par \cf4 FileIndex\cf0  is the index into the indexed properties of the archive for the file being skipped (if unzipping), for instance Filename[FileIndex] or CompressedSize[FileIndex].
\par   
\par If this event is called during a zipping process and the reason for skipping is srFileOpenError, setting \cf4 Retry\cf0  to True will cause VCLZip to re-attempt to open the file.  This gives you a chance to close the file if it is open by another application and continue zipping, rather than having to start the zipping all over again.  Setting the Retry parameter will be ignored if it is not a zipping situation and if the reason is not srFileOpenError.  See the \strike FileOpenMode\strike0\fs24{\v Scribble3245}\fs22  property which determines the mode used to open files about to be zipped.  
\par 
\par \cf1 IMPORTANT:\cf0    \b If FileIndex is -1\b0 , this means that this event has been called during a zipping operation. In this case, use the FName parameter only as this reflects a file that is not in the archive, instead FName reflects the name of a file that would have been zipped.  Do not try to use the FileIndex property or an error will occur.  
\par 
\par \b Definition of each reason (TSkipReason) and why OnSkippingFile would be called:\b0   
\par 
\par \pard\fi-2400\li2400\tx2400\tx720 srBadPassword\tab\cf4 When unzipping\cf0 , If an attempt is made to process an encryped file and the Password property does not match the file's password.  
\par srNoOverwrite\tab\cf4 When unzipping\cf0 , If an existing file would be overwritten and the OverWriteMode property is set to either Never, or Prompt and the OnPromptForOverwrite event returned False for the OverWriteIt parameter. 
\par \tab\cf4  When zipping\cf0 , if about to insert a duplicate entry into the archive. (This should happen rarely as conflicts should be taken care of by VCLZip before it reaches this point. Please contact me if this happens)  
\par srFileOpenError\tab (Version 2.16 or later only)\cf4  When zipping\cf0 , if an error occurs opening a file about to be zipped. This will probably mean that the file is locked by another application.  You can set the \strike FileOpenMode\strike0\fs24{\v Scribble3245}\fs22  property to determine the mode to use to open the file about to be zipped.  
\par \pard\fi-2400\li2400\tx2400  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2525}
{\up $}{\footnote {\up $} OnStartUnZipInfo Event }
{\up +}{\footnote {\up +} vclunzip:000430}
{\up K}{\footnote {\up K} Events;OnStartUnZipInfo;}
{\up A}{\footnote {\up A} TVCLUnZip_OnStartUnZipInfo;OnStartUnZipInfo_Event;OnStartUnZipInfo}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnStartUnZipInfo Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnStartUnZipInfo: \cf2 TStartUnzipInfo\cf0  = \b procedure\b0 (Sender: TObject; NumFiles: Integer; TotalBytes: Comp; \b var\b0  StopNow: Boolean); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnStartUnzipInfo event handler is executed just before the first file is to be extracted, giving you a chance to abort. NumFiles is the total number of files that is about to be processed.  TotalBytes is the total number of uncompressed bytes that make up the files about to be extracted.  Set StopNow to True if you do not wish continue the operation.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2530}
{\up $}{\footnote {\up $} OnTotalPercentDone Event }
{\up +}{\footnote {\up +} vclunzip:000440}
{\up K}{\footnote {\up K} Events;OnTotalPercentDone;Progress;}
{\up A}{\footnote {\up A} TVCLUnZip_OnTotalPercentDone;OnTotalPercentDone_Event;OnTotalPercentDone}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnTotalPercentDone Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnTotalPercentDone: \cf2 TTotalPercentDone\cf0  = \b procedure\b0 (Sender: TObject; Percent: LongInt); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnTotalPercentDone event handler is triggered periodically to report the progress of the total bytes of all the files that are being processed.  Percent represents a percentage between 1 and 100.  
\par  
\par \f1 This event will be called not only during zipping and unzipping, but also while writing/saving files from an original zip file when modifiying an existing zip file.  One tip here is to set a flag in the \cf2\strike OnStartZipInfo\cf3\strike0{\v Scribble3305}\cf0  event\f0  \f1 so that you know which situation this event is being called.  Anything before the OnStartZipInfo event is a result of moving original files while anything after OnStartZipInfo will be a result of actual compression.  Ofcourse when unzipping there is no saving of previous files so this is irrelavent.
\par 
\par During compression/decompression the percentage is based on the total number of bytes zipped/unzipped compared to the total number of bytes to zip/unzip.  During saving of original files, the percentage is based on number of files saved compared to the total number of files to be saved.
\par \f0\fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2535}
{\up $}{\footnote {\up $} OnUnZipComplete Event }
{\up +}{\footnote {\up +} vclunzip:000450}
{\up K}{\footnote {\up K} Events;OnUnZipComplete;}
{\up A}{\footnote {\up A} TVCLUnZip_OnUnZipComplete;OnUnZipComplete_Event;OnUnZipComplete}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnUnZipComplete Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnUnZipComplete: \cf2 TUnZipComplete\cf0  = \b procedure\b0 (sender: TObject; FileCount: Integer); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnUnZipComplete event handler is triggered at the very end of an UnZip process, after ALL files have been unzipped. Note that this event is not triggered after each file is unzipped.  For that you would use the \strike OnEndUnZip Event\strike0\fs24{\v Scribble2745}\fs22 .  
\par 
\par The FileCount parameter that is passed into the event contains the total number of files that were successfully unzipped.  
\par 
\par This event will rarely be used since the same information can be obtained from the return value from the call to the \strike UnZip Method\strike0\fs24{\v Scribble2640}\fs22 .  This event is mainly can be useful when using VCLZip in threads where in certain circumstances the return from the UnZip method is not seen.  
\par 
\par See Also:  
\par 
\par \strike OnZipComplete Event\strike0\fs24{\v Scribble3310}\fs22 , \strike OnEndUnZip Event\strike0\fs24{\v Scribble2745}\fs22   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2540}
{\up $}{\footnote {\up $} OperationMode property}
{\up +}{\footnote {\up +} vclunzip:000460}
{\up K}{\footnote {\up K} OperationMode;}
{\up A}{\footnote {\up A} TVCLUnZip_OperationMode;OperationMode_Property;OperationMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OperationMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OperationMode: \cf2 TOperationMode\cf0  = (omZip, omUnZip, omNone);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f6 
\par This is set according to which operation (zipping or unzipping) is currently taking place.  If neither, then this property is set to omNone.
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2545}
{\up $}{\footnote {\up $} OverwriteMode property}
{\up +}{\footnote {\up +} vclunzip:000470}
{\up K}{\footnote {\up K} OverwriteMode;}
{\up A}{\footnote {\up A} TVCLUnZip_OverwriteMode;OverwriteMode_Property;OverwriteMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OverwriteMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OverwriteMode: \cf2 TUZOverwriteMode\cf0  = (Prompt, Always, Never, ifNewer, ifOlder);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set OverwriteMode to determine what should be done if a file is about to be extracted and a file of the same name already exists in the destination directory.  The possible modes are  
\par 
\par \pard\li600\cf4 TUZOverwriteMode = (Prompt, Always, Never, ifNewer, ifOlder);   ( The default is Prompt )  
\par \cf0 
\par \pard\fi-1440\li1440\tx1440\tx720\ul\b Setting\tab Action Taken\ulnone\b0   
\par \b Prompt\b0\tab One of two things will happen.  If the \strike OnPromptForOverwrite\strike0\fs24{\v Scribble2515}\fs22  event is defined then it will be called and the application can decide whether to overwrite the file.  If the OnPromptForOverwrite event is NOT defined then the component will display a messagebox to allow the user to decide whether to overwrite the file.  
\par \b Always\b0\tab The file will be overwritten.  
\par \b Never\b0\tab Tthe file will not be extracted if it would overwrite a file.  
\par \b ifNewer\b0\tab The file will only overwrite the existing one if the archived file is newer than the existing one.  
\par \b ifOlder\b0\tab The file will only overwrite the existing one if the archived file is older than the existing one.  
\par \pard   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2550}
{\up $}{\footnote {\up $} Password property}
{\up +}{\footnote {\up +} encryption:000070}
{\up K}{\footnote {\up K} Encryption;Password;AES;Strong Encryption}
{\up A}{\footnote {\up A} TVCLUnZip_Password;Password_Property;Password}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Password property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Password: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If set to anything but a blank string, this password will be used when compressing data or uncompressing encryped files.
\par   
\par See Also:  
\par 
\par \pard{\pntext\f5\'B7\tab}{\*\pn\pnlvlblt\pnf5\pnindent0{\pntxtb\'B7}}\fi-180\li180\tx180\tx4100\cf2\strike\f1 EncryptStrength property\cf3\strike0{\v Scribble2554} \cf0\f0 
\par \cf2\strike{\pntext\f5\'B7\tab}EncryptionStrength property\cf3\strike0{\v Scribble2553}\cf0  
\par \cf2\strike{\pntext\f5\'B7\tab}OnBadPassword Event \cf3\strike0{\v Scribble2490}\cf0  
\par \cf2\strike{\pntext\f5\'B7\tab}IsEncrypted property\cf3\strike0{\v Scribble2450}\cf0 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  
\par \f6\fs16 Published, Writable\f7 
\par 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2553}
{\up $}{\footnote {\up $} EncryptionStrength property}
{\up +}{\footnote {\up +} encryption:000010}
{\up K}{\footnote {\up K} Encryption;Password;AES;Strong Encryption}
{\up A}{\footnote {\up A} TVCLUnZip_EncryptionStrength;EncryptionStrength_Property;EncryptionStrength}
}
\viewkind4\uc1\pard\cf4\lang1033\b\fs32 EncryptionStrength property\f7 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  \f2 EncryptionStrength[Index: Integer]: TEncryptStrength = (esPKStandard, esAES128, esAES192, esAES256);
\par \f3 
\par \f7 
\par \b\fs22 Description\f6    \cf1\b0 (\ul This property is new in VCLZip 4\ulnone )
\par \cf0\b\f7 
\par \pard\b0\f1 This is a readonly property and lets you know, for the selected index (specific file), what the encryption strength is.  This is mainly useful if you want to display the encryption strength for files in an archive.
\par 
\par In order to SET the encryption strength when creating an encrypted archive, set the \cf2\strike EncryptStrength Property\cf3\strike0{\v Scribble2554}\cf0 . 
\par \f0 
\par See Also:
\par 
\par \cf2\strike EncryptStrength property\cf3\strike0{\v Scribble2554}\cf0   
\par \strike\f1 Pass\f0 word \f1 Property\strike0\f0\fs24{\v Scribble2550}\fs22  
\par \strike OnBadPassword Event\strike0\fs24{\v Scribble2490}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\strike IsEncrypted property\cf3\strike0{\v Scribble2450}\cf0 
\par 
\par \f7\fs16 Run-time only
\par 
\par \pard\cf4\b\fs32 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2554}
{\up $}{\footnote {\up $} EncryptStrength property}
{\up +}{\footnote {\up +} encryption:000020}
{\up K}{\footnote {\up K} Encryption;Password;AES;Strong Encryption}
{\up A}{\footnote {\up A} TVCLZip_EncryptStrength;EncryptStrength_Property;EncryptStrength}
}
\viewkind4\uc1\pard\cf4\b\fs32 EncryptStrength property\f7 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip component\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  \f2 EncryptStrength: TEncryptStrength = (esPKStandard, esAES128, esAES192, esAES256) default esPKStandard;
\par \f7 
\par \b\fs22 Description\f6    \cf1\b0 (\ul This property is new in VCLZip 4\ulnone )\cf0\b\f7 
\par 
\par \pard\b0\f1 This is a published writable property and lets you set the encryption strength that you wish to use when creating an encrypted archive.  For backwards compatability, the default is esPKStandard which is the old PKZip encryption method.  This method is not considered to be strong encryption.  If you wish to use strong encryption, chose one of the other options.  The higher the number, the stronger the encryption.  That is, esAES256 is stronger encryption than esAES192, and esAES192 is stronger than esAES128.  Note that PKZip and WinZip will only encrypt using 128 and 256 bit but will read 192 bit encrypted files.
\par 
\par Note this property is different from the EncryptionStrength Property which provides the EncryptStrength that was used to encrypt the file.
\par 
\par \f0 See Also: 
\par 
\par \strike\f1 EncryptionStrength\f0  \f1 Property\strike0\f0\fs24{\v Scribble2553}\fs22  
\par \strike\f1 Pass\f0 word \f1 Property\strike0\f0\fs24{\v Scribble2550}\fs22  
\par \strike OnBadPassword Event\strike0\fs24{\v Scribble2490}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\strike IsEncrypted property\cf3\strike0{\v Scribble2450}\cf0 
\par 
\par \pard 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  
\par \f6\fs16 Published\f7 
\par 
\par \pard\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2555}
{\up $}{\footnote {\up $} Pathname property}
{\up +}{\footnote {\up +} vclunzip:000490}
{\up K}{\footnote {\up K} Indexed Properties;Pathname;}
{\up A}{\footnote {\up A} TVCLUnZip_Pathname;Pathname_Property;Pathname}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Pathname property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Pathname[Index\f2 ]\f3 : Integer: TZipPathname;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Pathname property returns just the pathname portion of the file, without the filename.  This does include a '\\' at the end.  
\par 
\par If you are using VCLZip, this property is also writable.  Once you have opened up a zip file you may set this property, thereby modifying what is already contained by this property.  It is up to you to be sure not to modify this in such a way that you would end up with two files in the zip archive with the same Filename and Pathname.  
\par 
\par If you do set Pathname, the archive will be flagged as modified.  After setting all of the Pathnames that you wish to set, you should call the \strike SaveModifiedZipFile Method\strike0{\v Scribble3445} to save the archive with the new Pathnames.  
\par 
\par \pard\li240 Reading Pathname: 
\par 
\par \pard\tx720\cf4\tab ThisPath  := VCLZip.Pathname[i]; 
\par  
\par \pard\li240\cf0 Writing Pathname: 
\par 
\par \pard\li120\tx720\cf4\tab VCLZip.Pathname[i] := NewPath; 
\par \pard\li240\tx720\tab SaveModifiedZipFile;  
\par \pard\cf0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2560}
{\up $}{\footnote {\up $} RecreateDirs property}
{\up +}{\footnote {\up +} vclunzip:000500}
{\up K}{\footnote {\up K} RecreateDirs;}
{\up A}{\footnote {\up A} TVCLUnZip_RecreateDirs;RecreateDirs_Property;RecreateDirs}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RecreateDirs property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  RecreateDirs: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set this property to True if you want to use directory information in the zipfile when extracting files.  The directories will be created relative to the DestDir (Destination Directory).  If this property is False, all files will be extracted to the DestDir, which could possibly result in files of the same name overwriting each other if the OverwriteMode property is set to Always.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2565}
{\up $}{\footnote {\up $} RelativePathList property}
{\up +}{\footnote {\up +} vclunzip:000510}
{\up K}{\footnote {\up K} Paths;RelativePathList;}
{\up A}{\footnote {\up A} TVCLUnZip_RelativePathList;RelativePathList_Property;RelativePathList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RelativePathList property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  RelativePathList: TStrings;
\par \f7 
\par \b\fs22 Description
\par 
\par \pard\f0 When Zipping:\b0  
\par \f1\fs20 W\f0 hen storing relative path information using the \strike RelativePaths Property\strike0{\v Scribble3340}, you must use this property to specify the director\f1 ies\f0  from where path information will begin being saved.  See \strike RelativePaths\strike0{\v Scribble3340} for more information on this topic.  Essentially the value\f1 s in RelativePathList\f0  will be stripped from the saved path information. 
\par 
\par \f1 So if you put 'c:\\somedir\\*.*' into the FilesList and set RelativePathList.Add('c:\\somedir') and set the Recurse property to True, then VCLZip Pro will store relative paths for all files from somedir on down through all subdirectories.  Files in somedir will have no path information stored, files in c:\\somedir\\subdir will only have subdir\\ stored as path information and so on.
\par \f0 
\par \f1 Adding multiple entries in RelativePathList allows you to create archives using RelativePaths from different anchor directories.  For instance if you had:
\par 
\par \tab c:\\one\\dir1\\file1
\par \tab c:\\one\\dir2\\file2
\par \tab c:\\one\\dir3\\file3
\par \tab c:\\two\\dir1\\file4
\par \tab c:\\two\\dir2\\file5
\par \f0 
\par \f1 and you wanted to store files in the archive like:
\par 
\par \tab dir1\\file1
\par \tab dir1\\file4
\par \tab dir2\\file2
\par \tab dir2\\file5
\par \tab dir3\\file3
\par 
\par then you can add the following to RelativePathList:
\par 
\par \tab RelativePathList.Add('c:\\one');
\par \tab RelativePathLIst.Add('c:\\two');
\par 
\par which essentially takes the left part of the path of each file and looks for any matches int the entries in RelativePathList. If so, the matching string in RelativePathList is stripped from the path of the file being zipped. 
\par \f0 
\par \b When UnZipping:\b0  
\par Using the \f1 RelativePathList\f0  when unzipping allows you to extract files from an archive that was not created using the relative paths option and still treat it as though it was.  In this case you should set \f1 values in RelativePathList\f0  to the value\f1 s\f0  that you want stripped from the internal path information for each file that is unzipped.  For instance, if you had an archive containing the following information:  
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\ul\b Filename\ulnone\tab\ul Path Info\ulnone\b0   
\par \pard\fi-2400\li2400\tx2400 file1.txt\tab backups\\subdir1\\ 
\par file2.txt\tab backups\\subdir1\\subdir2\\ 
\par file3.txt\tab backups\\subdir1\\subdir3\\ 
\par 
\par \pard and you wished to extract these files to a \strike DestDir\strike0{\v Scribble2375} of c:\\restore\\ and retain the directory structure, normally you would end up with something like the following being extracted:  
\par 
\par c:\\restore\\backups\\subdir1\\file1.txt 
\par c:\\restore\\backups\\subdir1\\subdir2\\file2.txt 
\par c:\\restore\\backups\\subdir1\\subdir3\\file3.txt 
\par 
\par when what you really wanted was:
\par   
\par c:\\restor\f1 e\\subdir1\f0\\file1.txt 
\par c:\\restore\\subdir1\\subdir2\\file2.txt 
\par c:\\restore\\subdir1\\subdir3\\file3.txt 
\par 
\par You can produce the desired results simply by setting  
\par 
\par \pard\li360\f1 RelativePathList.Add(\f0 'backups\\'\f1 )\f0 ;  
\par 
\par \pard before extracting.  What this does is effectively strip 'backups\\' from the internal path information of each file prior to extracting.  Remember that you should set RootDir according to how the path information is stored in the archive.  Do not begin it with a '\\' character and if the path information includes disk information then you should include that also. 
\par  
\par Note that if RootDir is not a substring of the internal path information then this action will not happen.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f6  \f7 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2570}
{\up $}{\footnote {\up $} ReplaceReadOnly property}
{\up +}{\footnote {\up +} vclunzip:000520}
{\up K}{\footnote {\up K} ReplaceReadOnly;}
{\up A}{\footnote {\up A} TVCLUnZip_ReplaceReadOnly;ReplaceReadOnly_Property;ReplaceReadOnly}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ReplaceReadOnly property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ReplaceReadOnly: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If set to True, allows files with the READONLY attribute to be replaced by an unzip operation.  If set to False, any file that is being unzipped that trys to replace a READONLY file will be skipped and the \strike OnSkippingFile Event\strike0\fs24{\v Scribble2520}\fs22  will be called.  
\par 
\par This is a published property so it can be set in the Object Inspector.  
\par The default value for ReplaceReadOnly is False.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2575}
{\up $}{\footnote {\up $} RetainAttributes property}
{\up +}{\footnote {\up +} vclunzip:000530}
{\up K}{\footnote {\up K} RetainAttributes;}
{\up A}{\footnote {\up A} TVCLUnZip_RetainAttributes;RetainAttributes_Property;RetainAttributes}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RetainAttributes property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  RetainAttributes: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The RetainAttributes property should be set to true if you wish unzipped files to retain the attributes that they had when they were originally zipped.  
\par  
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2580}
{\up $}{\footnote {\up $} RootDir property}
{\up +}{\footnote {\up +} vclunzip:000540}
{\up K}{\footnote {\up K} Paths;RootDir;}
{\up A}{\footnote {\up A} TVCLUnZip_RootDir;RootDir_Property;RootDir}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RootDir property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  RootDir: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par 
\par \pard\f0 When Zipping:\b0  
\par The RootDir property determines where zipping will start for any wildcard entries or filenames in the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22  that do not already include path information.  Essentially, the value of RootDir will be prepended to anything in the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  that does not have any path information when zipping. 
\par  
\par Also, when storing relative path information using the \strike RelativePaths Property\strike0\fs24{\v Scribble3340}\fs22 , you must use this RootDir property to specify the directory from where path information will begin being saved.  See \strike RelativePaths\strike0\fs24{\v Scribble3340}\fs22  for more information on this topic.  Essentially the value of RootDir will be stripped from the saved path information in this case.  
\par 
\par \b When UnZipping:\b0  
\par Using the RootDir when unzipping allows you to extract files from an archive that was not created using the relative paths option and still treat it as though it was.  In this case you should set RootDir to the value that you want stripped from the internal path information for each file that is unzipped.  For instance, if you had an archive containing the following information:
\par   
\par \pard\fi-2400\li2400\tx2400\tx720\ul\b Filename\ulnone\tab\ul Path Info\ulnone\b0   
\par \pard\fi-2400\li2400\tx2400 file1.txt\tab backups\\subdir1\\ 
\par file2.txt\tab backups\\subdir1\\subdir2\\ 
\par file3.txt\tab backups\\subdir1\\subdir3\\
\par  
\par \pard and you wished to extract these files to a \strike DestDir\strike0\fs24{\v Scribble2375}\fs22  of c:\\restore\\backups and retain the directory structure, normally you would end up with something like the following being extracted:  
\par 
\par c:\\restore\\backups\\backups\\subdir1\\file1.txt 
\par c:\\restore\\backups\\backups\\subdir1\\subdir2\\file2.txt 
\par c:\\restore\\backups\\backups\\subdir1\\subdir3\\file3.txt 
\par 
\par when what you really wanted was:
\par   
\par c:\\restore\\backups\\subdir1\\file1.txt 
\par c:\\restore\\backups\\subdir1\\subdir2\\file2.txt 
\par c:\\restore\\backups\\subdir1\\subdir3\\file3.txt 
\par 
\par You can produce the desired results simply by setting  
\par 
\par \pard\li360\cf4 RootDir := 'backups\\subdir1\\';  
\par \cf0 
\par \pard before extracting.  What this does is effectively strip 'backups\\subdir1\\' from the internal path information of each file prior to extracting.  Remember that you should set RootDir according to how the path information is stored in the archive.  Do not begin it with a '\\' character and if the path information includes disk information then you should include that also. 
\par  
\par Note that if RootDir is not a substring of the internal path information then this action will not happen.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2585}
{\up $}{\footnote {\up $} Selected property}
{\up +}{\footnote {\up +} vclunzip:000550}
{\up K}{\footnote {\up K} Indexed Properties;Selected;}
{\up A}{\footnote {\up A} TVCLUnZip_Selected;Selected_Property;Selected}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Selected property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Selected[Index\f2 ]\f3 : Integer: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setting this property to True for any file in an archive will allow you to unzip it using one of the unzip methods that unzip files based on its index.  For instance the following will unzip all files .TXT files in the archive: 
\par  
\par \pard\li240\cf4 With VCLZip1 do begin ZipName := 'c:\\test\\test.zip';  /* Open existing zip file */ 
\par \pard\li720 For i := 0 to Count-1 do 
\par \pard\li1440 If UpperCase(ExtractFileExt(Filename[i])) = '.TXT' then 
\par \pard\li1800\b Selected[i]\b0  := True;  /* Flag text files as selected */ 
\par \pard\li720 DestDir := 'c:\\test\\newdir'; 
\par NumUnZipped := UnZipSelected; 
\par \pard\li360 end; 
\par \cf0 
\par \pard After returning from the UnZipSelected method, all files will have their Selected property set back to False; 
\par  
\par See Also:
\par   
\par \strike ClearSelected\strike0\fs24{\v Scribble2680}\fs22  
\par \strike NumSelected\strike0\fs24{\v Scribble2475}\fs22  
\par \strike UnZipSelected\strike0\fs24{\v Scribble2645}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2590}
{\up $}{\footnote {\up $} SortMode property}
{\up +}{\footnote {\up +} vclunzip:000560}
{\up K}{\footnote {\up K} SortMode;}
{\up A}{\footnote {\up A} TVCLUnZip_SortMode;SortMode_Property;SortMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SortMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  SortMode: TZipSortMode = (ByName, ByFileName, ByDirectoryName, ByDate,\f2  \f3 ByCompressedSize,ByUnCompressedSize, ByRate, ByNone);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set this property to determine what order the information from the zipfile will be in when it is read.  In order to re-sort the information if it has already been read in, call the \cf2\strike Sort method\cf3\strike0{\v Scribble2735}\cf0 .  
\par 
\par Note: ByName sorts by path+filename.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2595}
{\up $}{\footnote {\up $} ThisVersion property}
{\up +}{\footnote {\up +} vclunzip:000570}
{\up K}{\footnote {\up K} ThisVersion;Version;}
{\up A}{\footnote {\up A} TVCLUnZip_ThisVersion;ThisVersion_Property;ThisVersion}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ThisVersion property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  This\f2 Build\f3 : Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This property simply returns the current version of VCLUnZip and VCLZip.\f1  Used along with the \cf2\strike ThisBuild property\cf3\strike0{\v Scribble2598}\cf0  you can always tell exactly what version/build you are working with.\f0   It is an integer where the last two digits represent the minor version and the remaining \f1 prior \f0 digits represent the major version number.  For example, 202 represents version 2.02.  This is a published property and so it can always be seen in the Property Inspector too.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2598}
{\up $}{\footnote {\up $} ThisBuild property}
{\up K}{\footnote {\up K} ThisBuild;Version;}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 This\f6 Build\f7  property\cf3\cf4 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf0\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  This\f2 Build\f3 : Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This property simply returns the current \f1 Build\f0  \f1 Number \f0 of VCLUnZip and VCLZip.  \f1 Used along with the \cf2\strike ThisVersion property\cf3\strike0{\v Scribble2595} you can tell exactly what version and build of VCLZip you are working with. \cf0\f0 It is \f1 simply an integer from 1..n.\f0   This is a published property and so it can always be seen in the Property Inspector too.  
\par \pard  
\par \f7\fs20 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2600}
{\up $}{\footnote {\up $} UnCompressedSize property}
{\up +}{\footnote {\up +} vclunzip:000580}
{\up K}{\footnote {\up K} Indexed Properties;UnCompressedSize;}
{\up A}{\footnote {\up A} TVCLUnZip_UnCompressedSize;UnCompressedSize_Property;UnCompressedSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnCompressedSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  UnCompressedSize[Index\f2 ]\f3 : Integer: BIGINT;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnCompressedSize property returns the uncompressed size of the file.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2605}
{\up $}{\footnote {\up $} ZipComment property}
{\up +}{\footnote {\up +} vclunzip:000590}
{\up K}{\footnote {\up K} Comments;ZipComment,FileComment;}
{\up A}{\footnote {\up A} TVCLUnZip_ZipComment;ZipComment_Property;ZipComment}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipComment property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ZipComment: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipComment property returns the zipfile's comment if there is one.  For 16 bit (Delphi 1) no more than 255 characters of the comment are returned.  
\par 
\par You may (as of version 2.19) simply set the ZipComment property directly, before calling any of the Zip methods when either creating a new zip file, or when adding or updating an existing zip file.  For instance: 
\par  
\par \cf4\f8 With VCLZip1 do 
\par \pard\li120 begin 
\par \pard\li360 ZipName := 'c:\\mydir\\MyArchive.ZIP'; 
\par ZipComment := 'This is a comment'; 
\par FilesList.Add('c:\\test\\*.*'); FilesList.Add('c:\\backups\\*.*); Zip; 
\par \pard\li120 end; 
\par 
\par \pard\cf0 If all you want to do is modify or add a zip comment for an existing archive (not zipping any additional files) then you should call the \strike SaveModifiedZipFile Method\strike0\f0{\v Scribble3445}\f8  to save the archive with the new ZipComment.  
\par Something like the following: 
\par  
\par \cf4 With VCLZip1 do 
\par \pard\li120 begin 
\par \pard\li360 ZipName := 'c:\\mydir\\MyArchive.ZIP'; 
\par ReadZip; 
\par ZipComment := 'This is a comment'; 
\par SaveModifiedZipFile; 
\par \pard\li120 end; 
\par 
\par \pard\cf0\f0 Keep in mind that you cannot add or modify a zip comment for an existing spanned or blocked archive. You cannot modify spanned or blocked archives in any way once they have been created.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2610}
{\up $}{\footnote {\up $} ZipHasComment property}
{\up +}{\footnote {\up +} vclunzip:000600}
{\up K}{\footnote {\up K} Comments;FileComment;ZipComment;ZipHasComment;}
{\up A}{\footnote {\up A} TVCLUnZip_ZipHasComment;ZipHasComment_Property;ZipHasComment}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipHasComment property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ZipHasComment: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipHasComment property returns True if the zipfile itself has a comment.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2615}
{\up $}{\footnote {\up $} ZipName property}
{\up +}{\footnote {\up +} vclunzip:000610}
{\up K}{\footnote {\up K} ZipName;}
{\up A}{\footnote {\up A} TVCLUnZip_ZipName;ZipName_Property;ZipName}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipName property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ZipName: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipName property specifies the path and name of the zipfile that you plan to work with. This must, ofcourse, be set before you can do anything with or get information from the zipfile.  After setting the ZipName you should call ReadZip to cause the zipfile's information to be read (Calling ReadZip is optional if you do not plan to access the Indexed Properties before unzipping files. Performing any operation will cause ReadZip to be automatically called if it hasn't already been called).  
\par 
\par Setting ZipName to a '?' will cause a fileopen dialogbox to be displayed so that a file can be selected.  If you set ZipName to '?' and the user presses the cancel button on the FileOpen dialog box, a EUserCanceled exception will be thrown and ZipName, along with all other properties will remain unchanged.  You may include a pathname along with the '?' if you wish the fileopen dialog box to begin in a certain directory.  For example 
\par  
\par \pard\li600\cf4\f1 ZipName := '\f0 c:\\backup\\?\f1 '\f0   
\par \cf0 
\par \pard will cause a fileopen dialog box to be displayed beginning in the directory c:\\backup 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2620}
{\up $}{\footnote {\up $} ZipSize property}
{\up +}{\footnote {\up +} vclunzip:000620}
{\up K}{\footnote {\up K} ZipSize;}
{\up A}{\footnote {\up A} TVCLUnZip_ZipSize;ZipSize_Property;ZipSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ZipSize: BIGINT;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipSize property returns the size of the current zipfile specified by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  in bytes.   If the zip file is a spanned archive, this property returns only the size of the currently open part of the archive.  \f1 The maximum for VCLZip Lite is 2 gig while the maximum for VCLZip Pro is 2^63 bytes.\f0 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2625}
{\up $}{\footnote {\up $} CheckArchive method}
{\up +}{\footnote {\up +} vclunzip:000630}
{\up K}{\footnote {\up K} CheckArchive;}
{\up A}{\footnote {\up A} TVCLUnZip_CheckArchive;CheckArchive_Method;CheckArchive}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CheckArchive method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  CheckArchive: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This method is used to check the integrity of an entire archive.  It will process the archive specified by \strike ZipName\strike0\fs24{\v Scribble2615}\fs22 . In order to test the integrity of a single file within an archive, use the \strike FileIsOK Property\strike0\fs24{\v Scribble2415}\fs22 .  
\par This function will return True if the archive tests ok and false if any of the files do not test ok.  This could be one or more files that are corrupt in the archive.  In order to tell which files are corrupt during the call to CheckArchive, you should define a \strike OnBadCRC Event\strike0\fs24{\v Scribble2485}\fs22  which will be called for each bad file.  Using the FileIndex parameter that is passed in to this event procedure, you can tell which file is bad. 
\par  
\par \cf1 IMPORTANT: \cf0  Please be aware that CheckArchive will clear the FilesList, so you will have to populate the FilesList \b AFTER\b0  calling CheckArchive if you plan on using FilesList to zip or unzip specific files after calling CheckArchive.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2630}
{\up $}{\footnote {\up $} DecryptHeaderByte method}
{\up +}{\footnote {\up +} vclunzip:000640}
{\up K}{\footnote {\up K} BCB;DecryptHeaderByte;Encryption;}
{\up A}{\footnote {\up A} TVCLUnZip_DecryptHeaderByte;DecryptHeaderByte_Method;DecryptHeaderByte}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DecryptHeaderByte method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  DecryptHeaderByte(Passwrd: \b string\b0 ; dh: DecryptHeaderType): BYTE;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This function is used in conjunction with the \strike DecryptHeader\strike0\fs24{\v Scribble2370}\fs22  property to determine if a password matches the password key of a file.  This function is only needed if doing low level work with passwords and encrypted zip files. 
\par  
\par If you are developing in BCB you should use the \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  method instead.  
\par 
\par See Also: 
\par  
\par \strike DecryptHeader\strike0\fs24{\v Scribble2370}\fs22  
\par \strike GetDecryptHeaderByteByPtr\strike0\fs24{\v PG62}\fs22  
\par \strike GetDecryptHeaderPtr\strike0\fs24{\v Scribble2710}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2635}
{\up $}{\footnote {\up $} DecryptHeaderByteByPtr method}
{\up +}{\footnote {\up +} vclunzip:000650}
{\up K}{\footnote {\up K} BCB;DecryptHeaderByteByPtr;Encryption;}
{\up A}{\footnote {\up A} TVCLUnZip_DecryptHeaderByteByPtr;DecryptHeaderByteByPtr_Method;DecryptHeaderByteByPtr}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DecryptHeaderByteByPtr method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  DecryptHeaderByteByPtr(Passwrd: \b string\b0 ; dh: BytePtr): Byte;
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 <<< Description of DecryptHeaderByteByPtr method >>>
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2640}
{\up $}{\footnote {\up $} UnZip method}
{\up +}{\footnote {\up +} vclunzip:000660}
{\up K}{\footnote {\up K} Decompress;UnZip;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZip;UnZip_Method;UnZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZip: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZip method causes the files defined in FilesList property to be extracted.  If FilesList is empty then all files in the zip file are extracted.  The return value is the number of files successfully unzipped.  
\par  \f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2645}
{\up $}{\footnote {\up $} UnZipSelected method}
{\up +}{\footnote {\up +} vclunzip:000670}
{\up K}{\footnote {\up K} Decompress;UnZip;UnZipSelected;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZipSelected;UnZipSelected_Method;UnZipSelected}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZipSelected method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZipSelected: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZipSelected method causes the files that have had their \strike Selected\strike0\fs24{\v Scribble2585}\fs22  property set to True, to be extracted. The return value is the number of files successfully unzipped. 
\par  
\par The following will unzip all .TXT files: 
\par  
\par \cf4   With VCLZip1 do 
\par \pard\li360 For i := 0 to Count-1 do 
\par \pard\li720 If UpperCase(ExtractFileExt(FileName[i])) = '.TXT' then 
\par \pard\li1080 Selected[i] := True; 
\par \pard\li120 NumUnZipped := UnZipSelected; 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf0\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2650}
{\up $}{\footnote {\up $} UnZipToBuffer method}
{\up +}{\footnote {\up +} vclunzip:000680}
{\up K}{\footnote {\up K} Decompress;UnZip;UnZipToBuffer;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZipToBuffer;UnZipToBuffer_Method;UnZipToBuffer}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZipToBuffer method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZipToBuffer(\b var\b0  Buffer: PChar; FName: \b string\b0 ): Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZipToBuffer method unzips the file specified by \b FName\b0  parameter from the zip file specified by the \strike ZipName\strike0\fs24{\v Scribble2615}\fs22  property directly to the memory buffer specified by \b Buffer\b0  pointer parameter.  The length of the buffer is expected to be able to handle the length of the file being unzipped which can be determined by the \strike UnCompressedSize Property\strike0\fs24{\v Scribble2600}\fs22 .  
\par 
\par If you pass in \b Buffer\b0  with a value of nil then Buffer will be allocated at exactly the size of the uncompressed file by VCLUnZip and passed back to you.  It will then be your responsibility to free that memory using a call to FreeMem. 
\par  
\par \b Return Value  
\par \b0 The return value will be 1 if the buffer was extracted and 0 if it was not successfully unzipped.  
\par Buffered output (using a smaller buffer than the total size of the uncompressed file) is possible by setting the \strike BufferLength\strike0\fs24{\v Scribble2325}\fs22  property to the size of your buffer, or the amount of output that you want VCLZip to process at a time.  By setting BufferLength, the \strike OnGetNextBuffer Event\strike0\fs24{\v Scribble2500}\fs22  will be called after each BufferLength bytes have been unzipped. 
\par  
\par As an example, the following shows how to unzip directly into a String and attach it to a TMemo component as its text:  
\par \cf4  
\par \pard\fi-5400\li5400\tx5400\tx720 n := FileDialog.FileBox.ItemIndex;\tab /* Get the index of the file to unzip */ 
\par SetLength(Buffer, Zipper.UnCompressedSize[n]);\tab /* Set the length of the string */ 
\par BufPtr := @Buffer[1]\tab /* Point a PChar at the first character of the string */; 
\par Zipper.UnZipToBuffer(BufPtr, CurrentFile );\tab /* Unzip into the string */ 
\par TextMemo.Lines.Text := Buffer;\tab /* Use that string as the TMemo's text */ 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf0\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2655}
{\up $}{\footnote {\up $} UnZipToBufferByIndex method}
{\up +}{\footnote {\up +} vclunzip:000690}
{\up K}{\footnote {\up K} Decompress;UnZip;UnZipToBufferByIndex;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZipToBufferByIndex;UnZipToBufferByIndex_Method;UnZipToBufferByIndex}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZipToBufferByIndex method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZipToBufferByIndex(\b var\b0  Buffer: PChar; Index: Integer): Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZipToBufferByIndex method unzips the file specified by the \b Index\b0  parameter from the zip file specified by the \strike ZipName\strike0\fs24{\v Scribble2615}\fs22  property directly to the memory buffer specified by \b Buffer\b0  pointer parameter.  The length of the buffer is expected to be able to handle the length of the file being unzipped which can be determined by the \strike UnCompressedSize Property\strike0\fs24{\v Scribble2600}\fs22 . 
\par  
\par If you pass in \b Buffer\b0  with a value of nil then Buffer will be allocated at exactly the size of the uncompressed file by VCLUnZip and passed back to you.  It will then be your responsibility to free that memory using a call to FreeMem.
\par   
\par \b Return Value  
\par \b0 The return value will be 1 if the buffer was extracted and 0 if it was not successfully unzipped.  
\par As an example, the following shows how to unzip directly into a String and attach it to a TMemo component as its text:  
\par \cf4  
\par \pard\fi-5400\li5400\tx5400\tx720 n := FileDialog.FileBox.ItemIndex;\tab /* Get the index of the file to unzip */ 
\par SetLength(Buffer, Zipper.UnCompressedSize[n]);\tab /* Set the length of the string */ 
\par BufPtr := @Buffer[1]\tab /* Point a PChar at the first character of the string */; 
\par Zipper.UnZipToBufferByIndex(BufPtr, n );\tab /* Unzip  into the string */ 
\par TextMemo.Lines.Text := Buffer;\tab /* Use that string as the TMemo's text */ 
\par \pard\cf0   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2660}
{\up $}{\footnote {\up $} UnZipToStream method}
{\up +}{\footnote {\up +} vclunzip:000700}
{\up K}{\footnote {\up K} Decompress;UnZip;UnZipToStream;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZipToStream;UnZipToStream_Method;UnZipToStream}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZipToStream method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZipToStream(theStream: TkpStream; FName: \b string\b0 ): Integer;
\par \f6 // D4,D5,BCB4,BCB5 only...\f7 
\par \b\f3 function\b0  UnZipToStream(theStream: TStream; FName: \b string\b0 ): Integer;\f2  \b overload\b0 ;\f3 
\par \f7 
\par 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZipToStream method unzips the file specified by theFile parameter from the zip file specified by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\f1  or from the \cf2\strike ArchiveStream\f0\fs22  \cf3\strike0{\v Scribble2310}\cf0\f1  \f0 directly to the stream specified by theStream parameter. 
\par 
\par \f1 The overloaded version of this method that is defined for D4, D5, BCB4, and BCB5 only, allow these versions of Delphi/BCB to unzip to a normal TStream.  Note that you should not do this if there is a chance that the file you are unzipping might be larger than 2 gig in size since TStreams in these versions do not handle files larger than this.\f0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2665}
{\up $}{\footnote {\up $} UnZipToStreamByIndex method}
{\up +}{\footnote {\up +} vclunzip:000710}
{\up K}{\footnote {\up K} Decompress;UnZip;UnZipToStreamByIndex;}
{\up A}{\footnote {\up A} TVCLUnZip_UnZipToStreamByIndex;UnZipToStreamByIndex_Method;UnZipToStreamByIndex}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UnZipToStreamByIndex method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  UnZipToStreamByIndex(theStream: TkpStream; Index: Integer): Integer;
\par \f6 // D4, D5, BCB4, and BCB5 only...\f7 
\par \b\f3 function\b0  UnZipToStreamByIndex(theStream: TStream; Index: Integer): Integer;\f2  \b overload\b0 ;\f3 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The UnZipToStreamByIndex method is the same as the \strike UnZipToStream Method\strike0\fs24{\v Scribble2660}\fs22  except that you pass in the Index instead of the filename of the file to be unzipped.  It unzips the file specified by the Index parameter from the zip file specified by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\f1  or from the \cf2\strike ArchiveStream\cf3\strike0{\v Scribble2310}\cf0 ,\f0\fs22  directly to the stream specified by theStream parameter.
\par   
\par For example the following will unzip the first .TXT file in the archive:  
\par 
\par \cf4 myStream := TMemoryStream.Create; 
\par While i < Count do 
\par \pard\li360 If UpperCase(ExtractFileExt(Filename[i])) = '.TXT' then 
\par \pard\li480 begin 
\par \pard\li840 UnZiptoStreamByIndex( myStream, i ); 
\par break; 
\par \pard\li480 end; 
\par \cf0 
\par \pard\f1 The overloaded version of this method that is defined for D4, D5, BCB4, and BCB5 only, allows these versions of Delphi/BCB to unzip to a normal TStream.  Note that you should not do this if there is a chance that the file you are unzipping might be larger than 2 gig in size since TStreams in these versions do not handle files larger than this.\f0  \f1  Remember that in D6, D7, and BCB6, TkpStream = TStream as in these versions of Delphi/BCB TStreams have Int64 capabilities.\f0 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2670}
{\up $}{\footnote {\up $} AskForNewDisk method}
{\up +}{\footnote {\up +} vclunzip:000720}
{\up K}{\footnote {\up K} TVCLUnZip,AskForNewDisk;}
{\up A}{\footnote {\up A} TVCLUnZip_AskForNewDisk;AskForNewDisk_Method;AskForNewDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 AskForNewDisk method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  AskForNewDisk(NewDisk: Integer);
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 <<< Description of AskForNewDisk method >>>
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2675}
{\up $}{\footnote {\up $} CancelTheOperation method}
{\up +}{\footnote {\up +} vclunzip:000730}
{\up K}{\footnote {\up K} CancelTheOperation;}
{\up A}{\footnote {\up A} TVCLUnZip_CancelTheOperation;CancelTheOperation_Method;CancelTheOperation}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CancelTheOperation method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  CancelTheOperation;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The CancelTheOperation method causes the current zipping or unzipping operation to be canceled.  This is useful if you wish to abort a very long operation before it is finished.  If the \strike DoProcessMessages Property\strike0\fs24{\v Scribble2390}\fs22  is set to False, calling this procedure will have no effect. 
\par 
\par \f1 The operation will cancel just before the next clearing of the buffer, so it may not be instantaneous.\f0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2680}
{\up $}{\footnote {\up $} ClearSelected method}
{\up +}{\footnote {\up +} vclunzip:000740}
{\up K}{\footnote {\up K} ClearSelected;}
{\up A}{\footnote {\up A} TVCLUnZip_ClearSelected;ClearSelected_Method;ClearSelected}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ClearSelected method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  ClearSelected;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Call this procedure to set the \strike Selected\strike0\fs24{\v Scribble2585}\fs22  property for all files to False;  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2685}
{\up $}{\footnote {\up $} ClearZip method}
{\up +}{\footnote {\up +} vclunzip:000750}
{\up K}{\footnote {\up K} ClearZip;}
{\up A}{\footnote {\up A} TVCLUnZip_ClearZip;ClearZip_Method;ClearZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ClearZip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  ClearZip;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ClearZip method removes all of the zip information from memory.  The component is still ready to open another zipfile, or even the same zip file.  Opening another zipfile will take care of this for you so this is usually optional.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2695}
{\up $}{\footnote {\up $} DefaultFileNameForSplitPart method}
{\up +}{\footnote {\up +} vclunzip:000760}
{\up K}{\footnote {\up K} DefaultFileNameForSplitPart;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_DefaultFileNameForSplitPart;DefaultFileNameForSplitPart_Method;DefaultFileNameForSplitPart}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DefaultFileNameForSplitPart method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  DefaultFileNameForSplitPart(Sender: TObject; \b var\b0  FName: \b String\b0 ; PartNum: Integer; SplitType: TSplitPartType);
\par \f7 
\par \b\fs22 Description
\par 
\par \b0\f6\fs20 This procedure is called internally if you do not have an \cf2\strike OnFileNameForSplitPart event\cf3\strike0{\v Scribble2750}\cf0  defined. It will set the filenames to be used when creating each part of a blocked archive.  Below is a snapshot of the code used in this method at the time of this writing. See \cf2\strike OnFileNameForSplitPart event\cf3\strike0{\v Scribble2750}\cf0  for the filenaming schemes used by this method. 
\par \b\f7\fs22 
\par \cf4\b0\fs20 procedure TVCLUnZip.DefaultFileNameForSplitPart(Sender: TObject; var FName: String; PartNum: Integer;
\par                 SplitType: TSplitPartType);
\par begin
\par   if (BlockMode = bmStandard) then
\par   begin
\par     if (SplitType = spLast) then
\par       FName := Fname + '.zip.'
\par     else
\par       FName := FName + '.zip.' + Format('z%2.2d', [PartNum]);
\par   end
\par   else
\par       FName := FName + Format('%3.3d', [PartNum]);
\par end;
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2700}
{\up $}{\footnote {\up $} DefaultGetNextDisk method}
{\up +}{\footnote {\up +} vclunzip:000770}
{\up K}{\footnote {\up K} DefaultGetNextDisk;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_DefaultGetNextDisk;DefaultGetNextDisk_Method;DefaultGetNextDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DefaultGetNextDisk method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  DefaultGetNextDisk(Sender: TObject; NextDisk: Integer; \b var\b0  FName: \b string\b0 );
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \f6 See \cf2\strike OnGetNextDisk Event \cf3\strike0{\v Scribble2505}\cf0\f7 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2705}
{\up $}{\footnote {\up $} FillList method}
{\up +}{\footnote {\up +} vclunzip:000780}
{\up K}{\footnote {\up K} FillList;}
{\up A}{\footnote {\up A} TVCLUnZip_FillList;FillList_Method;FillList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FillList method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  FillList(FilesList: TStrings);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FillList method fills the string list with tab delimited information on each file.  Useful if you want to display information on all files in a listbox.  It is usually best to just used the indexed properties so that you can fill the fileslist the way you want.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2710}
{\up $}{\footnote {\up $} GetDecryptHeaderPtr method}
{\up +}{\footnote {\up +} vclunzip:000790}
{\up K}{\footnote {\up K} BCB;Encryption;GetDecryptHeaderPtr;}
{\up A}{\footnote {\up A} TVCLUnZip_GetDecryptHeaderPtr;GetDecryptHeaderPtr_Method;GetDecryptHeaderPtr}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 GetDecryptHeaderPtr method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  GetDecryptHeaderPtr(Index: Integer; dhPtr: BytePtr);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This method is mainly for use in BCB and is analogous to the \strike DecryptHeader\strike0\fs24{\v Scribble2370}\fs22  which should be used if developing in Delphi. 
\par  
\par You should allocate dhPtr prior to calling this method, as a 12 byte array.  
\par 
\par This method should only be called for files that are password encrypted, however if you do call this method for a file that is not password encrypted, the 12 byte array that dhPtr points to, will contain all zero's. 
\par  
\par This function is used in conjunction with the \strike GetDecryptHeaderByteByPtr\strike0\fs24{\v PG62}\fs22  method to determine if a password matches the password key of a file.  This function is only needed if doing low level work with passwords and encrypted zip files.  
\par 
\par See Also:
\par   
\par \strike DecryptHeader\strike0\fs24{\v Scribble2370}\fs22  
\par \strike DecryptHeaderByte\strike0\fs24{\v Scribble2630}\fs22  
\par \strike GetDecryptHeaderByteByPtr\strike0\fs24{\v PG62}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2715}
{\up $}{\footnote {\up $} PauseTheOperation method}
{\up +}{\footnote {\up +} vclunzip:000800}
{\up K}{\footnote {\up K} PauseTheOperation;}
{\up A}{\footnote {\up A} TVCLUnZip_PauseTheOperation;PauseTheOperation_Method;PauseTheOperation}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 PauseTheOperation method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  PauseTheOperation;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The \f1 Pause\f0 TheOperation method causes the current zipping or unzipping operation to be \f1 paused\f0 .  \f1 To resume operations call \cf2\strike RestartTheOperation\cf3\strike0{\v Scribble2730}\cf0\f0 .  If the \strike DoProcessMessages Property\strike0\fs24{\v Scribble2390}\fs22  is set to False, calling this procedure will have no effect. 
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2720}
{\up $}{\footnote {\up $} ReadZip method}
{\up +}{\footnote {\up +} vclunzip:000810}
{\up K}{\footnote {\up K} ReadZip;}
{\up A}{\footnote {\up A} TVCLUnZip_ReadZip;ReadZip_Method;ReadZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ReadZip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  ReadZip;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ReadZip method causes the zip file to be opened and all pertinant information to be read from the zip file.  The information on each file can be accessed by the indexed properties described later.  You should call this procedure after setting the ZipName property. This procedure only needs to be called if you plan to access the files information such as Filename[Index] before performing an operation.  You can call the UnZip or Zip or any functions without calling ReadZip first.  
\par 
\par If KeepZipOpen is set to False, ReadZip will open the zip file, read it's information and then close the zip file.  If this is the case, should the zip file change before the next time you perform an operation on it, the zip's information will automatically be updated.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2725}
{\up $}{\footnote {\up $} ResetFileIsOK method}
{\up +}{\footnote {\up +} vclunzip:000820}
{\up K}{\footnote {\up K} ResetFileIsOK;}
{\up A}{\footnote {\up A} TVCLUnZip_ResetFileIsOK;ResetFileIsOK_Method;ResetFileIsOK}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ResetFileIsOK method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  ResetFileIsOK(Index: Integer);
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 <<< Description of ResetFileIsOK method >>>
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2730}
{\up $}{\footnote {\up $} RestartTheOperation method}
{\up +}{\footnote {\up +} vclunzip:000830}
{\up K}{\footnote {\up K} RestartTheOperation;}
{\up A}{\footnote {\up A} TVCLUnZip_RestartTheOperation;RestartTheOperation_Method;RestartTheOperation}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RestartTheOperation method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  RestartTheOperation;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The \f1 Restart\f0 TheOperation method causes the current zipping or unzipping operation to \f1 resume after having called \cf2\strike PauseTheOperation\cf3\strike0{\v Scribble2715}\cf0\f0 .  \f1 To resume operations call RestartTheOperation\f0 .  If the \strike DoProcessMessages Property\strike0\fs24{\v Scribble2390}\fs22  is set to False, calling this procedure will have no effect.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2735}
{\up $}{\footnote {\up $} Sort method}
{\up +}{\footnote {\up +} vclunzip:000840}
{\up K}{\footnote {\up K} Sort;}
{\up A}{\footnote {\up A} TVCLUnZip_Sort;Sort_Method;Sort}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Sort method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  Sort(SMode: TZipSortMode);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Sort method sorts the zip information according to \strike SortMode Property\strike0\fs24{\v Scribble2590}\fs22 .  The default sort mode is ByNone.  
\par 
\par \ul\b\fs25 WARNING\ulnone\b0\fs22  
\par If you are working with a multi-part zip file, it is most efficient to have the zip information sorted with \strike SortMode\strike0\fs24{\v Scribble2590}\fs22  = ByNone.  If you have the information sorted by any other mode and you are working with a mulit-part file, the component will have to sort the information using the ByNone mode and then sort the information back to the way you had it sorted.   This will only be noticable on zip files containing a large number of entries.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2740}
{\up $}{\footnote {\up $} OnDecrypt event}
{\up +}{\footnote {\up +} encryption:000060}
{\up K}{\footnote {\up K} Encryption;Events;OnDecrypt;Password;}
{\up A}{\footnote {\up A} TVCLUnZip_OnDecrypt;OnDecrypt_Event;OnDecrypt}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnDecrypt event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnDecrypt: TDecryptEvent\f2  \f3 = \b procedure\b0 (Sender: TObject; buffer: BytePtr; length: Integer; Password: \b String\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Define this event if you wish to perform your own encryption and decryption instead of the normal pkzip encryption. Use this with care as this is still somewhat experimental and I'm not sure how useful it is yet.  You must make all changes within the buffer sent in to you.  Treat the entire file as a stream.  Byte for byte replacement only. No additional keys can be saved.  
\par 
\par The buffer pointer that is passed in, points to  the data that is to be Decrypted.  The length (in bytes) of the buffer is passed in in the length parameter.  Do not change the buffer pointer.  Do not change the length of the buffer in any way. Essentially all that is allowed is a byte for byte replacement within the buffer.  The Password parameter contains whatever is in the \strike Password Property\strike0\fs24{\v Scribble2550}\fs22 . 
\par  
\par See Also:
\par   
\par \strike OnEncrypt\strike0\fs24{\v Scribble3465}\fs22  
\par \strike Password\strike0\fs24{\v Scribble2550}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2745}
{\up $}{\footnote {\up $} OnEndUnZip event}
{\up +}{\footnote {\up +} vclunzip:000860}
{\up K}{\footnote {\up K} Events;OnEndUnZip;}
{\up A}{\footnote {\up A} TVCLUnZip_OnEndUnZip;OnEndUnZip_Event;OnEndUnZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnEndUnZip event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnEndUnZip: TEndUnZipEvent = \b procedure\b0 (Sender: TObject; FileIndex: Integer; FName: \b string\b0 ); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnEndUnZip event handler is triggered just after each file has been extracted.  The FName parameter contains the full path to the file that was just unzipped which will allow you to further process this file in any way if you wish.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2750}
{\up $}{\footnote {\up $} OnFileNameForSplitPart event}
{\up +}{\footnote {\up +} vclunzip:000870}
{\up K}{\footnote {\up K} Events;OnFileNameForSplitPart;Spanning;}
{\up A}{\footnote {\up A} TVCLUnZip_OnFileNameForSplitPart;OnFileNameForSplitPart_Event;OnFileNameForSplitPart}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnFileNameForSplitPart event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnFileNameForSplitPart: \cf2 TFileNameForSplitPartEvent\cf0  = \b procedure\b0 (Sender: TObject; \b var\b0  FName: \b String\b0 ; PartNum: Integer; SplitType: TSplitPartType); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\fs20 
\par \cf1\f0\fs22  NOTE:\cf0  If you do not define this event then \f1 the \cf2\strike DefaultFileNameForSplitPart method\cf3\strike0{\v Scribble2695}\cf0\f0  is \f1 internally called and\f0  will handle both zipping and unzipping cases.
\par \f7\fs20 
\par \f6\fs24 This event is called to create the proper filenames for blocked archives, that is, archives created with \cf2\strike MultiMode \cf3\strike0{\v Scribble2465} \cf0 set to mmBlocks.  It is called just before creating each part, including the first part which is numbered 1.
\par 
\par \cf4 FName\cf0  is the value of \cf2\strike ZipName property\cf3\strike0{\v Scribble2615} with the file extension removed\cf0 .  This should be set to the correct filename for the part about to be made usually by attaching the correct file extension, however you can use whatever filenaming scheme you wish.
\par 
\par \cf4 PartNum\cf0  is the number of the part about to be created, starting with 1.
\par 
\par \cf4 SplitType\cf0  is one of (spFirst, spMiddle, spLast, spUnknown) depending on whether the part about to be made is the First, one of the Middle, or the Last part of the split archive.
\par 
\par The \cf2\strike\f1\fs22 DefaultFileNameForSplitPart method\cf3\strike0{\v Scribble2695}\cf0\f6\fs24  creates filenames one of two ways, depending on how \cf2\strike BlockMode\cf3\strike0{\v Scribble2315}\cf0  is set.  If set to
\par 
\par \pard\fi-2100\li2100\tx2080\tx2100\cf4 bmStandard\cf0\tab\tab creates files according the pkzip standard.  filename.zip becomes \cf1 filename.zip.z01, filename.zip.z02...filename.zip\cf0 .  The last part is simply the original filename.  VCLZip detects that it is a split file.
\par 
\par \cf4 bmClassic\cf0\tab creates files the way VCLZip always created them in the past.  filename.zip becomes \cf1 filename.001, filename.002..filename.nnn\cf0 .  The last filename has the number of the part as the extension.
\par \pard 
\par 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640 See \cf2\strike\f1\fs22 DefaultFileNameForSplitPart method\cf3\strike0{\v Scribble2695} for a snapshot of the code at the time of this writing.\cf0\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2755}
{\up $}{\footnote {\up $} OnHandleMessage event}
{\up +}{\footnote {\up +} vclunzip:000880}
{\up K}{\footnote {\up K} Events;OnHandleMessage;}
{\up A}{\footnote {\up A} TVCLUnZip_OnHandleMessage;OnHandleMessage_Event;OnHandleMessage}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnHandleMessage event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnHandleMessage: THandleMessageEvent = \b procedure\b0 (Sender: TObject; \b const\b0  MessageID: Integer; \b const\b0  Msg1: \b String\b0 ; \b const\b0  Msg2: \b String\b0 ; \b const\b0  flags: LongWord; \b var\b0  Return: Integer); \b of\b0  \b Object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \f6 VCLZip handles all interfacing with the GUI through an internal default OnHandleMessage event, unless you define your own OnHandleMessage event.  If you wish, for instance, to avoid writing to a GUI (say for instance you are running in a DLL), you can write event and consume them.
\par 
\par The internal default event looks like this:
\par 
\par \cf4 function TVCLUnZip.DefaultHandleMessage(const MessageID: Integer; const Msg1: String; const Msg2: String; const flags: LongWord): Integer;
\par var
\par   m1, m2: PChar;
\par begin
\par      m1 := StrToPChar(Msg1);
\par      m2 := StrToPchar(Msg2);
\par      Result := MessageBox(0,m1,m2,flags);
\par      StrDispose(m1);
\par      StrDispose(m2);
\par end;
\par  
\par \cf0 Here is an example of a call that VCLZip makes to this event to prompt for overwrite of a file.
\par 
\par     \cf4 StrPCopy( MsgArray, LoadStr(IDS_REPLACEFILE) + Filename[Index] + '?' );
\par     tmpMStr := LoadStr(IDS_FILEXISTALERT);
\par     OverWriteIt := DoHandleMessage(IDS_FILEXISTALERT,MsgArray, StringAsPChar(tmpMStr), MB_YESNO) = IDYES;
\par \f7 
\par \cf0\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble2760}
{\up $}{\footnote {\up $} OnStartUnZip event}
{\up +}{\footnote {\up +} vclunzip:000890}
{\up K}{\footnote {\up K} Events;OnStartUnZip;}
{\up A}{\footnote {\up A} TVCLUnZip_OnStartUnZip;OnStartUnZip_Event;OnStartUnZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnStartUnZip event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLUnZip\cf3\strike0{\v Scribble2300}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnStartUnZip: TStartUnZipEvent = \b procedure\b0 (Sender: TObject; FileIndex: Integer; \b var\b0  FName: \b string\b0 ; \b var\b0  Skip: Boolean); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnStartUnZip event handler is triggered just before a file is about to be extracted.  FName is the complete path and filename of the file that is about to be unzipped.  Notice that it is a VAR parameter.  This allows you to modify the destination and filename of the file just before it is unzipped.  If you do this, be sure it is a complete and valid filename, including the device, path, and filename.  If the destination directory does not exist, then VCLZip will create the complete directory path for you.
\par   
\par If you wish to skip this file altogether (don't unzip it) then just set Skip to True.  
\par 
\par \cf1\b NOTE:\cf0\b0  Prior to VCLZip 2.18, FName was not a VAR parameter and could not be modified.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3110}
{\up $}{\footnote {\up $} BlockSize property}
{\up +}{\footnote {\up +} vclzip:000010}
{\up K}{\footnote {\up K} BlockSize;TMultiZipInfo;}
{\up A}{\footnote {\up A} TMultiZipInfo_BlockSize;BlockSize_Property;BlockSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 BlockSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  BlockSize: Int64;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The BlockSize property determines the size of each file that is created as a part of a \strike Blocked Zip File\strike0\fs24{\v PG2}\fs22 .  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3120}
{\up $}{\footnote {\up $} FirstBlockSize property}
{\up +}{\footnote {\up +} vclzip:000020}
{\up K}{\footnote {\up K} FirstBlockSize;TMultiZipInfo;}
{\up A}{\footnote {\up A} TMultiZipInfo_FirstBlockSize;FirstBlockSize_Property;FirstBlockSize}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FirstBlockSize property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FirstBlockSize: Int64;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FirstBlockSize property determines the size of the \ul FIRST\ulnone  file that is created as a part of a \strike  Blocked Zip File\strike0{\v PG2}. Each file after that is created according to the \strike BlockSize Property\strike0{\v Scribble3110}.  You may wish to make FirstBlockSize smaller than BlockSize, for instance, if you want to leave room on a first disk of an installation disk set for installation files.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3125}
{\up $}{\footnote {\up $} MultiMode property}
{\up +}{\footnote {\up +} vclzip:000030}
{\up K}{\footnote {\up K} MultiMode;TMultiZipInfo;}
{\up A}{\footnote {\up A} TMultiZipInfo_MultiMode;MultiMode_Property;MultiMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 MultiMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  \f8\fs22 MultiZipInfo.\f3\fs20 MultiMode: TMultiMode = (mmNone, mmSpan, mmBlocks);
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The MultiMode property determines whether a multi-part zip file will be created as several files on the same disk or a a zip file that actually spans physical disks.
\par   
\par \pard\fi-2400\li2400\tx2400\tx720\ul\b Value\ulnone\tab\ul Meaning\ulnone\b0   
\par mmNone\tab Normal zip files  
\par mmSpan\tab Zip file will physically span disks (if large enough)  
\par mmBlocks\tab Zip file will be broken into separate files (blocks) on the same disk (typically to be copied to separate disks later).  
\par 
\par \pard When using the VCLUnZip component you should set this property as follows:
\par   
\par \pard\tx360\tab\cf4 UnZipper.MultiMode := mmNone;\cf0  
\par  
\par \pard When using the VCLZip component, you may set or read this property the same way, or you may access it through the \strike MultZipInfo Property\strike0{\v Scribble3280} as follows:
\par   
\par \pard\tx360\tab\cf4 Zipper.MultiZipInfo.MultiMode := mmBlocks;\cf0   
\par 
\par \pard When opening a zip file, (that is after calling the \strike ReadZip Method\strike0{\v Scribble2720}) if a multi-file zip file is detected, this property is automatically set according to what type of media the zip file is on.  If the zip file is on a \b REMOVABLE\b0  disk, the multi-file zip is considered to be a \strike Spanned Disk Set\strike0{\v Scribble3280} with each file residing on a separate removable disk.  Therefore the MultiMode property is set to \cf4 mmSpan\cf0 .  If, however, the zip file is \b NOT\b0  on a \b REMOVABLE\b0  disk, it is considered to be a \strike Blocked Zip File\strike0{\v PG2} and this property is set to \cf4 mmBlocks\cf0 .  
\par After opening the zip file, you may modify this property if the automatic detection is not correct.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3130}
{\up $}{\footnote {\up $} SaveOnFirstDisk property}
{\up +}{\footnote {\up +} vclzip:000040}
{\up K}{\footnote {\up K} SaveOnFirstDisk;TMultiZipInfo;}
{\up A}{\footnote {\up A} TMultiZipInfo_SaveOnFirstDisk;SaveOnFirstDisk_Property;SaveOnFirstDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SaveOnFirstDisk property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  SaveOnFirstDisk: Int64;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Use this property when creating \strike Spanned Disk Zip Files\strike0{\v PG700} to save some room on the first disk for other files such as installation/setup files and/or a \strike Zip Configuration File\strike0{\v Scribble3135} (which allows VCLZip to open a spanned zip file from the first disk instead of the normally required last disk).  
\par 
\par See Also: 
\par  
\par \strike SaveZipInfoOnFirstDisk\strike0{\v Scribble3135} 
\par \strike Creating Spanned Disk Zip Files\strike0{\v PG700} 
\par \strike MultZipInfo Properties\strike0{\v Scribble3280} 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3135}
{\up $}{\footnote {\up $} SaveZipInfoOnFirstDisk property}
{\up +}{\footnote {\up +} vclzip:000050}
{\up K}{\footnote {\up K} SaveZipInfoOnFirstDisk;TMultiZipInfo;}
{\up A}{\footnote {\up A} TMultiZipInfo_SaveZipInfoOnFirstDisk;SaveZipInfoOnFirstDisk_Property;SaveZipInfoOnFirstDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SaveZipInfoOnFirstDisk property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  SaveZipInfoOnFirstDisk: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This property determines whether VCLZip will save a special Zip Configuration File on the first disk of a spanned zip file, when creating a spanned zip file (this works for blocked zip files too - that is spanned zip files created directly to your hard drive).  This will allow VCLZip to open the spanned zip file from the first disk of the set instead of requiring the last disk to be inserted.  
\par 
\par Normally, PKZip compatible spanned zip files require that the LAST disk of the disk set be inserted first in order to open up the zip file.  This often creates confusion and is an annoyance.  VCLZip has the unique capability to create and read spanned zip files which will allow VCLZip to open a spanned zip file from the first disk.  This option does not cause the spanned zip file to be non-PKZip compatible as PKZip, WinZip, and all of the other zip utilities can still open and read the spanned zip file normally (from the last disk).  However, VCLZip will, if this option is set to True, write some extra information onto the first disk in a separate file.  VCLZip will detect this file if the first disk is inserted first, and read from it, the information it would otherwise need the last disk to obtain. 
\par  
\par If this property is set to True before calling the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22  to create spanned zip file, then when the zip file has been completely created, VCLZip will ask you to re-insert the first disk of the spanned zip file.  VCLZip will then write out a special file called a Zip Configuration File which will be named the same as your zip file except it will have an extention of '.ZFC'.  If this first disk is ever the first disk inserted when trying to open up the zip file (which is a common mistake among users), VCLZip will automatically detect this file and use the information from it to get the contents of the spanned zip file. 
\par  
\par Note that other zip utilities will not be able to make use of this feature, only VCLZip will be able to use this file. 
\par  
\par \cf1\b IMPORTANT: \cf0\b0 VCLZip will attempt to save enough room on the first disk to allow for the Zip Configuration File to be written.   This amount will be added to the \strike SaveOnFirstDisk\strike0\fs24{\v Scribble3130}\fs22  property in the case of writing directly to removable media (MultiZipMode = mmSpan) or subtracted from the \strike FirstBlockSize\strike0\fs24{\v Scribble3120}\fs22  property in the case of creating the spanned zip file directly to the hard drive (MultiZipMode = mmBlocks).  If you are storing file comments,  fairly long filenames, or longer than usual path information, you may find that you might need to adjust the SaveOnFirstDisk or the FirstBlockSize property ahead of time to compensate for this somewhat.  
\par 
\par Basically the size of the Zip Configuration File, in bytes, will be approximately:  
\par 
\par ( Total Number of files * 46) + length of all filenames (including path information if saved) + length of each file comment + 22 + length of the zip comment.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3140}
{\up $}{\footnote {\up $} WriteDiskLabels property}
{\up +}{\footnote {\up +} vclzip:000060}
{\up K}{\footnote {\up K} Spanning;WriteDiskLabels;}
{\up A}{\footnote {\up A} TMultiZipInfo_WriteDiskLabels;WriteDiskLabels_Property;WriteDiskLabels}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 WriteDiskLabels property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 MultiZipInfo property\cf3\strike0{\v Scribble3280}\cf5 
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  WriteDiskLabels: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If set to True, the VCLZip component will write volume labels on each disk of a \strike Spanned Disk Set\strike0{\v PG700}.  These labels will be created just as PKZip would create them.  The first label will be PKBACK# 001, the second will be PKBACK# 002 and so on.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3200}
{\up $}{\footnote {\up $} TVCLZip component}
{\up +}{\footnote {\up +} vclzip:000070}
{\up K}{\footnote {\up K} TVCLZip;TVCLZip component;}
{\up A}{\footnote {\up A} TVCLZip_Object;TVCLZip}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 TVCLZip component
\par \cf0\b0\fs16 
\par \pard\keepn\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\ul See also\cf3\ulnone{\v %Scribble3201}\tab\cf2\ul Properties\cf3\ulnone{\v %Scribble3202}\tab\cf2\ul Methods\cf3\ulnone{\v %Scribble3203}\tab\cf2\ul Events\cf3\ulnone{\v %Scribble3204}\cf5\cf0\b\fs22 
\par \pard\cf5\b0\fs20 
\par \cf0\b\fs22 Description
\par \pard\b0\f0 The VCLZip component inherits from TVCLZip and adds capabilites for creating and modifying zip files.  When modifying an existing zip file, all output goes to a temporary file in the Windows temporary directory or, if the \strike TempPath\strike0\fs24{\v Scribble3370}\fs22  property is defined, output goes to the directory that it specifies.  Once processing is finished, if there were no exceptions, then the original file is deleted and the temporary file replaces it.  If there are any exceptions, then the temporary file is deleted and the original file stays intact.  
\par 
\par \cf1\b NOTE:\cf0\b0 You do not need to use both a VCLUnZip and VCLZip component in order to perform UnZip and Zip operations.  VCLZip alone will handle all zipping and unzipping operations for you.  
\par  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3201}
{\up $}{\footnote {\up $} TVCLZip component - See also}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 See also
\par \cf0\b0 
\par \cf2\strike TVCLUnZip component\cf3\strike0{\v Scribble2300}\cf0 
\par \cf2\strike TSFXConfig component\cf3\strike0{\v Scribble4010}\cf0 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3202}
{\up $}{\footnote {\up $} TVCLZip - Properties}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Properties
\par \cf0\b0 
\par \cf3\{bmct runtime.bmp\}\cf5  Run-time only\tab\cf3\{bmct key.bmp\}\cf5  Key properties
\par \pard\tx200\tx640\f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike AddDirEntriesOnRecurse\cf3\strike0{\v Scribble3210}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike CheckDiskLabels\cf3\strike0{\v Scribble2335}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Dispose\cf3\strike0{\v Scribble3225}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike EncryptStrength\cf3\strike0{\v Scribble2554}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ExcludeList\cf3\strike0{\v Scribble3230}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike FileOpenMode\cf3\strike0{\v Scribble3245}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike IncludeArchiveFiles\cf3\strike0{\v Scribble3250}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike IncludeHiddenFiles\cf3\strike0{\v Scribble3255}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike IncludeReadOnlyFiles\cf3\strike0{\v Scribble3260}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike IncludeSysFiles\cf3\strike0{\v Scribble3265}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike IsModified\cf3\strike0{\v Scribble3270}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike MultiZipInfo\cf3\strike0{\v Scribble3280}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike NoCompressList\cf3\strike0{\v Scribble3285}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike PackLevel\cf3\strike0{\v Scribble3320}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike PreserveStubs\cf3\strike0{\v Scribble3330}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Recurse\cf3\strike0{\v Scribble3335}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike RelativePaths\cf3\strike0{\v Scribble3340}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ResetArchiveBitOnZip\cf3\strike0{\v Scribble3345}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SkipIfArchiveBitNotSet\cf3\strike0{\v Scribble3350}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Store83Names\cf3\strike0{\v Scribble3355}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike StorePaths\cf3\strike0{\v Scribble3360}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike StoreVolumes\cf3\strike0{\v Scribble3365}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike TempPath\cf3\strike0{\v Scribble3370}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ZipAction\cf3\strike0{\v Scribble3375}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike ZipComment\cf3\strike0{\v Scribble2605}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3203}
{\up $}{\footnote {\up $} TVCLZip - Methods}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Methods
\par \cf0\b0 
\par \cf3\{bmct key.bmp\}\cf5  Key methods
\par \pard\tx200\tx640\f6\tab\tab\cf2\strike Create\cf3\strike0{\v ! ALink("Create_Method")}\cf5 
\par \tab\tab\cf2\strike Destroy\cf3\strike0{\v ! ALink("Destroy_Method")}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DeleteEntries\cf3\strike0{\v Scribble3385}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike FixZip\cf3\strike0{\v Scribble3390}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike MakeNewSFX\cf3\strike0{\v Scribble3395}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Split\cf3\strike0{\v Scribble3400}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Zip\cf3\strike0{\v Scribble3405}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ZipFromBuffer\cf3\strike0{\v Scribble3410}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf5 
\par \tab\tab\cf2\strike Assign\cf3\strike0{\v ! ALink("Assign_Method")}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike ExpandFilesList\cf3\strike0{\v Scribble3425}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike MakeSFX\cf3\strike0{\v Scribble3440}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SaveModifiedZipFile\cf3\strike0{\v Scribble3445}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SFXToZip\cf3\strike0{\v Scribble3450}\cf5 
\par \pard\li220\tx180\tx300\cf3\{bmct key.bmp\}\tab\cf2\strike ZLibCompressStream\cf3\strike0{\v Scribble5}\cf0\f7 
\par \cf3\f6\{bmct key.bmp\}\tab\cf2\strike ZLibCompressBuffer\cf3\strike0{\v Scribble8}\cf0\f7 
\par \cf3\f6\{bmct key.bmp\}\tab\cf2\strike ZLibCompressString\cf3\strike0{\v Scribble11}\cf0\f7 
\par \pard\tx200\tx640\fs16 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3204}
{\up $}{\footnote {\up $} TVCLZip - Events}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Events
\par \cf0\b0 
\par \cf3\{bmct key.bmp\}\cf5  Key events
\par \pard\tx200\tx640\f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnDeleteEntry\cf3\strike0{\v Scribble3455}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnDisposeFile\cf3\strike0{\v Scribble3460}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnEncrypt\cf3\strike0{\v Scribble3465}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnEndZip\cf3\strike0{\v Scribble3470}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnGetNextStream\cf3\strike0{\v Scribble3475}
\par \cf5\tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnGetNextTStream\cf3\strike0{\v Scribble3478}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnNoSuchFile\cf3\strike0{\v Scribble3480}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnStartZip\cf3\strike0{\v Scribble3485}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnUpdate\cf3\strike0{\v Scribble3490}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnPrepareNextDisk\cf3\strike0{\v Scribble3290}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnRecursingFile\cf3\strike0{\v Scribble3295}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnStartSpanCopy\cf3\strike0{\v Scribble3300}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnStartZipInfo\cf3\strike0{\v Scribble3305}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OnZipComplete\cf3\strike0{\v Scribble3310}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3210}
{\up $}{\footnote {\up $} AddDirEntriesOnRecurse property}
{\up +}{\footnote {\up +} vclzip:000080}
{\up K}{\footnote {\up K} AddDirEntriesOnRecurse;}
{\up A}{\footnote {\up A} TVCLZip_AddDirEntriesOnRecurse;AddDirEntriesOnRecurse_Property;AddDirEntriesOnRecurse}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 AddDirEntriesOnRecurse property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\ul See also\cf3\ulnone{\v %Scribble3211}\cf0\b\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  AddDirEntriesOnRecurse: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If AddDirEntriesOnRecurse is True, then when you do a recursive search through subdirectories (\strike Recurse\strike0\fs24{\v Scribble3335}\fs22  = True) a separate entry will be made in the archive for each directory.  This will allow even empty directories to be restored. 
\par  
\par If AddDirEntriesOnRecurse is False, path information will still be stored with each file that is compressed, but a separate entry will not be inserted for the directories. 
\par  
\par This property has no meaning unless \strike Recurse\strike0\fs24{\v Scribble3335}\fs22  = True. 
\par  
\par The resulting directory entries will have a \strike Filename\strike0\fs24{\v Scribble2420}\fs22 [Index] = '' (a blank filename) but will have a value for \strike Pathname\strike0\fs24{\v Scribble2555}\fs22 [Index].  When unzipping, these entries will cause that particular directory to be created if \strike RecreateDirs\strike0\fs24{\v Scribble2560}\fs22  = True.  
\par 
\par Default value is False.  
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3211}
{\up $}{\footnote {\up $} AddDirEntriesOnRecurse property - See also}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 See also
\par \pard\cf0\b0\strike\f0\fs22 Recurse\strike0\fs24{\v Scribble3335}\fs22  
\par \pard\strike RecreateDirs\strike0\fs24{\v Scribble2560}\fs22  
\par \f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3225}
{\up $}{\footnote {\up $} Dispose property}
{\up +}{\footnote {\up +} vclzip:000090}
{\up K}{\footnote {\up K} Dispose;}
{\up A}{\footnote {\up A} TVCLZip_Dispose;Dispose_Property;Dispose}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Dispose property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Dispose: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Dispose property, if set to True, will cause the original disk files that were added to the zip file to be deleted from the disk, in effect, moving the files into the zip file. \cf1 USE THIS OPTION WITH EXTREME CAUTION.\cf0  If an exception occurs during processing, files will not be deleted.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3230}
{\up $}{\footnote {\up $} ExcludeList property}
{\up +}{\footnote {\up +} vclzip:000100}
{\up K}{\footnote {\up K} ExcludeList;}
{\up A}{\footnote {\up A} TVCLZip_ExcludeList;ExcludeList_Property;ExcludeList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ExcludeList property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ExcludeList: TStrings;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Add filenames and/or wildcard specifications to this file list to specify files that you do not wish to be included in an archive when zipping.  This is useful, for for example, for excluding things like *.tmp files.  
\par \strike Wildcards\strike0\fs24{\v PG18}\fs22  may be used when adding to the ExcludeList. 
\par  
\par Example:  
\par 
\par To exlude all .tmp and .bak files, add the following lines before calling the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22 :  
\par ... \cf4 VCLZip1.ExcludeList.Add('*.bak'); VCLZip1.ExcludeList.Add('*.tmp');\cf0  ...  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3245}
{\up $}{\footnote {\up $} FileOpenMode property}
{\up +}{\footnote {\up +} vclzip:000110}
{\up K}{\footnote {\up K} FileOpenMode;}
{\up A}{\footnote {\up A} TVCLZip_FileOpenMode;FileOpenMode_Property;FileOpenMode}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FileOpenMode property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  FileOpenMode: Word;
\par \f7 
\par \b\fs22 Description
\par \pard\cf1\b0\f0 IMPORTANT:\cf0  As of version 2.21, default for \cf4 FileOpenMode\cf0  was changed back to \cf4 fmShareDenyNone\cf0  as it had been for all but version 2.20.  This allows VCLZip to backup open files.  If you do not want this behavior please set FileOpenMode accordingly.  In version 2.20 the default was \cf4 fmShareDenyWrite\cf0 .  
\par 
\par This property allows you to define the open mode for opening files that are about to be zipped.  If a file cannot be opened with this mode, then the \strike OnSkippingFile Event\strike0\fs24{\v Scribble2520}\fs22  will be called to let you know that file will not be zipped because it is already open by another process, and allow you to close that file and continue. This ONLY affects the opening of files that are being zipped.  
\par 
\par The default value is (\cf4 fmOpenRead or fmShareDenyNone\cf0 ).  This setting will allow VCLZip to backup files that are opened by other applications.  
\par 
\par You would set this property for instance if you want to be sure that VCLZip only backs up files if they are not opened by any other process at all.  In this case you would set this property as  
\par 
\par \pard\li360 FileOpenMode :=  \cf4 fmOpenRead or fmShareExclusive\cf0 ;  
\par 
\par \pard\b From the Delphi Help File:\b0   
\par \f1 The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and a share mode or'ed together. The open mode must be one of the following values: 
\par  \f0 
\par \pard\fi-2400\li2400\tx2400\tx720\b Value\tab Meaning\b0   
\par fmCreate\tab Create a file with the given name. If a file with the given name exists, open the file in write mode. 
\par fmOpenRead\tab Open the file for reading only. 
\par fmOpenWrite\tab Open the file for writing only. Writing to the file completely replaces the current contents. 
\par fmOpenReadWrite\tab Open the file to modify the current contents rather than replace them. 
\par \pard   
\par The share mode must be one of the following values:  
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\b Value\tab Meaning\b0   
\par fmShareCompat\tab Sharing is compatible with the way FCBs are opened. 
\par fmShareExclusive\tab Other applications can not open the file for any reason. 
\par fmShareDenyWrite\tab Other applications can open the file for reading but not for writing. 
\par fmShareDenyRead\tab Other applications can open the file for writing but not for reading. 
\par fmShareDenyNone\tab No attempt is made to prevent other applications from reading from or writing to the file. 
\par \pard   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3250}
{\up $}{\footnote {\up $} IncludeArchiveFiles property}
{\up +}{\footnote {\up +} vclzip:000120}
{\up K}{\footnote {\up K} IncludeArchiveFiles;Search Attribute;}
{\up A}{\footnote {\up A} TVCLZip_IncludeArchiveFiles;IncludeArchiveFiles_Property;IncludeArchiveFiles}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IncludeArchiveFiles property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IncludeArchiveFiles: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f6\fs20 
\par Sets the search attribute for zipping.  Set this to True if you wish to include files which have the archive bit set when zipping and using wildcards.  The default is True.
\par \f7 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3255}
{\up $}{\footnote {\up $} IncludeHiddenFiles property}
{\up +}{\footnote {\up +} vclzip:000130}
{\up K}{\footnote {\up K} IncludeHiddenFiles;Search Attribute;}
{\up A}{\footnote {\up A} TVCLZip_IncludeHiddenFiles;IncludeHiddenFiles_Property;IncludeHiddenFiles}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IncludeHiddenFiles property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IncludeHiddenFiles: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f6\fs20 
\par Sets the search attribute for zipping.  Set this to True if you wish to include hidden files when zipping and using wildcards.  The default is False.
\par \f7 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3260}
{\up $}{\footnote {\up $} IncludeReadOnlyFiles property}
{\up +}{\footnote {\up +} vclzip:000140}
{\up K}{\footnote {\up K} IncludeReadOnlyFiles;Search Attribute;}
{\up A}{\footnote {\up A} TVCLZip_IncludeReadOnlyFiles;IncludeReadOnlyFiles_Property;IncludeReadOnlyFiles}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IncludeReadOnlyFiles property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IncludeReadOnlyFiles: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\fs20 
\par \f6 Sets the search attribute for zipping.  Set this to True if you wish to include readonly files when zipping and using wildcards.  The default is True.
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3265}
{\up $}{\footnote {\up $} IncludeSysFiles property}
{\up +}{\footnote {\up +} vclzip:000150}
{\up K}{\footnote {\up K} IncludeSysFiles;Search Attribute;}
{\up A}{\footnote {\up A} TVCLZip_IncludeSysFiles;IncludeSysFiles_Property;IncludeSysFiles}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IncludeSysFiles property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IncludeSysFiles: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f6\fs20 
\par Sets the search attribute for zipping.  Set this to True if you wish to include system files when zipping and using wildcards.  The default is False.
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3270}
{\up $}{\footnote {\up $} IsModified property}
{\up +}{\footnote {\up +} vclzip:000160}
{\up K}{\footnote {\up K} IsModified;}
{\up A}{\footnote {\up A} TVCLZip_IsModified;IsModified_Property;IsModified}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 IsModified property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  IsModified: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The IsModified property is True if the current zip file has been modified but not yet saved (See the \strike SaveModifiedZipFile Method\strike0\fs24{\v Scribble3445}\fs22 ).  Currently the only operations that can cause a zip file to be modified without automatically immediately saving the zip file are:  
\par 
\par \pard\fi-360\li360\tx360\f1\bullet\tab\f0 Adding or modifying a \strike ZipComment Property\strike0\fs24{\v Scribble2605}\fs22  or any number of \strike FileComments\strike0\fs24{\v Scribble2405}\fs22 .  
\par \f1\bullet\tab\f0 Writing to any number of \strike Pathname Properties\strike0\fs24{\v Scribble2555}\fs22   
\par \f1\bullet\tab\f0 Writing to any number of \strike Filename Properties\strike0\fs24{\v Scribble2420}\fs22   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3280}
{\up $}{\footnote {\up $} MultiZipInfo property}
{\up +}{\footnote {\up +} vclzip:000170}
{\up K}{\footnote {\up K} MultiZipInfo;TMultiZipInfo;}
{\up A}{\footnote {\up A} TVCLZip_MultiZipInfo;MultiZipInfo_Property;MultiZipInfo}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 MultiZipInfo property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\ul\f6 Properties\cf3\ulnone\f7{\v %Scribble3282}\cf0\b\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  MultiZipInfo: TMultiZipInfo;
\par \f7 
\par \b\fs22 Description
\par 
\par \b0\f0 The MultiZipInfo Property contains most of the properties that deal with Spanned and Multi-File zip files.  It contains the following properties:  
\par 
\par \f1 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3282}
{\up $}{\footnote {\up $} MultiZipInfo property - Properties}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Properties
\par \cf0\b0 
\par \cf3\{bmct runtime.bmp\}\cf5  Run-time only\tab\cf3\{bmct key.bmp\}\cf5  Key properties
\par \pard\tx200\tx640\f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike BlockSize\cf3\strike0{\v Scribble3110}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike CheckDiskLabels\cf3\strike0{\v Scribble2335}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike FirstBlockSize\cf3\strike0{\v Scribble3120}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike MultiMode\cf3\strike0{\v Scribble3125}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SaveOnFirstDisk\cf3\strike0{\v Scribble3130}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike SaveZipInfoOnFirstDisk\cf3\strike0{\v Scribble3135}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike WriteDiskLabels\cf3\strike0{\v Scribble3140}\cf5 
\par \cf0\f7\fs16 
\par \pard\fs20 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3285}
{\up $}{\footnote {\up $} NoCompressList property}
{\up +}{\footnote {\up +} vclzip:000180}
{\up K}{\footnote {\up K} NoCompressList;}
{\up A}{\footnote {\up A} TVCLZip_NoCompressList;NoCompressList_Property;NoCompressList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 NoCompressList property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  NoCompressList: TStrings;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Add filenames and/or wildcard specifications to this file list to specify files that you do not wish VCLZip to attempt to compress when zipping, regardless of what \strike PackLevel\strike0\fs24{\v Scribble3320}\fs22  is set to. The files that match the entries in this list will be added to the archive with a \strike PackLevel\strike0\fs24{\v Scribble3320}\fs22  = 0, which means that it will be STORED in the archive with no compression at all.  This is useful when you wish to avoid having VCLZip try to compress files that won't compress much, if any, for instance zip archives that have already been compressed.
\par   
\par \strike Wildcards\strike0\fs24{\v PG18}\fs22  may be used when adding to the NoCompressList. 
\par  
\par Example:
\par   
\par To cause all zip and arj files to be STORED only in an archive when zipping, add the following prior to calling the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22 :  
\par 
\par ... \cf4 VCLZip1.NoCompressFiles.Add('*.arj'); VCLZip1.NoCompressFiles.Add('*.zip');\cf0  ...  
\par  
\par \fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3290}
{\up $}{\footnote {\up $} OnPrepareNextDisk Event }
{\up +}{\footnote {\up +} vclzip:000190}
{\up K}{\footnote {\up K} Events;OnPrepareNextDisk;Spanning;}
{\up A}{\footnote {\up A} TVCLZip_OnPrepareNextDisk;OnPrepareNextDisk_Event;OnPrepareNextDisk}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnPrepareNextDisk Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnPrepareNextDisk: TPrepareNextDisk = \b procedure\b0 (Sender: TObject; DiskNum: Integer); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 When creating a spanned zip file across removable media, this event is triggered directly after the \strike OnGetNextDisk Event\strike0\fs24{\v Scribble2505}\fs22  has been processed and just before the zipping process is continued.  This gives you a chance, from this event, to prepare the diskette in any way you wish. This is a good place to put code to format the disk, delete files from the disk, or even add special files if you wish.  After this event is done, the zipping process will continue with that part of the spanned zip file.  DiskNum is the number of the disk that you are working with.  The first disk in the spanned set would be number 1.  
\par 
\par Please note that before calling this event, VCLZip will already have deleted any zip files on the disk that match the name of the zip file being created, so you don't have to worry about using this event to do that youself.  
\par 
\par See Also:
\par   
\par \strike OnGetNextDisk Event\strike0\fs24{\v Scribble2505}\fs22   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3295}
{\up $}{\footnote {\up $} OnRecursingFile Event }
{\up +}{\footnote {\up +} vclzip:000200}
{\up K}{\footnote {\up K} Events;OnRecursingFile;}
{\up A}{\footnote {\up A} TVCLZip_OnRecursingFile;OnRecursingFile_Event;OnRecursingFile}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnRecursingFile Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnRecursingFile: TOnRecursingFile = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnRecursingFile event is called when VCLZip is recursing directories, searching for files that satisfy a wildcard that was entered into the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22 .  It is called for each file that is found that meets the criteria.  The FName parameter contains the filename of the file that was just found that meets the wildcard criteria.  
\par For instance if you did the following:  
\par 
\par \pard\li240\cf4 TVCLZip.Recurse := True; TVCLZip.RootDir := 'c:\\mydirs'; TVCLZip.FilesList.Add('*.pas'); NumZipped := TVCLZip.Zip;  
\par 
\par \pard\cf0 This event would be called for every .PAS file as it is found while VCLZip recurses the 'c:\\mydir' directory and all of it's subdirectories. 
\par  
\par All recursing is done prior to any actual zipping.  So this is a good way to show some sort of progress when you are recursing a large directory structure, otherwise your application may seem to be hung while the recursing is progressing.  Note that there can still be a long time between event calls if most files in a very large directory structure do not match the wildcard.  
\par 
\par For example in your OnRecursingFile event you may wish to do something like the following: 
\par  
\par \cf4\f8 procedure MyForm.OnOnRecursingFile( Sender: TObject; FName: String ); 
\par begin 
\par \pard\li360 StatusLabel.Caption := FName + ' matches wildcard and will be zipped'; 
\par \pard end; 
\par  
\par \cf0\f0 See Also: 
\par  
\par \strike OnStartZip\strike0\fs24{\v Scribble3485}\fs22  
\par \strike OnUpdate\strike0\fs24{\v Scribble3490}\fs22  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3300}
{\up $}{\footnote {\up $} OnStartSpanCopy Event }
{\up +}{\footnote {\up +} vclzip:000210}
{\up K}{\footnote {\up K} Events;OnStartSpanCopy;}
{\up A}{\footnote {\up A} TVCLZip_OnStartSpanCopy;OnStartSpanCopy_Event;OnStartSpanCopy}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnStartSpanCopy Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnStartSpanCopy: TOnStartSpanCopy;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f6 
\par When creating a \cf2\strike spanned or blocked archive\cf3\strike0{\v Scribble2465}\cf0  each file is first compressed to a temporary file and then copied to the archive that is being created.  This event is called just before the copy phase, providing the name of the file and the compressed size (size of the file being copied).   \b 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3305}
{\up $}{\footnote {\up $} OnStartZipInfo Event }
{\up +}{\footnote {\up +} vclzip:000220}
{\up K}{\footnote {\up K} Events;OnStartZipInfo;}
{\up A}{\footnote {\up A} TVCLZip_OnStartZipInfo;OnStartZipInfo_Event;OnStartZipInfo}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnStartZipInfo Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnStartZipInfo: TStartZipInfo = \b procedure\b0 (Sender: TObject; NumFiles: Integer; TotalBytes: Comp; \b var\b0  EndCentralRecord: TEndCentral; \b var\b0  StopNow: Boolean); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnStartZipInfo event handler is executed just before the first file of an archive is to be zipped, giving you a chance to abort.  You also receive useful information as well as the chance to add a zip comment at the time of creating the zip file. 
\par  
\par \cf1 IMPORTANT: \cf0 Be sure to include kpZipObj in your USES list if you plan on using this event!  It has the required definition of the TEndCentral object.  
\par 
\par The paramaters are:  
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\b NumFiles\b0\tab Total number of files that is about to be processed.  This may not be the actual number of files that ends up getting zipped for various reasons.  Check the return value of the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22  for the actual number of files that finally get zipped.  
\par \b TotalBytes\b0\tab Total number of uncompressed bytes that make up all of the files about to be zipped. 
\par \b StopNow\b0\tab Set this to True if you do not wish continue the zip operation. 
\par \b EndCentralRecord\b0\tab Use this to add a zip comment as follows:  
\par \pard\tx2400\tab\cf4 EndCentral.SetNewZipComment( 'This is a ZipComment' );\cf0   
\par \pard  
\par \cf3\fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf0\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3310}
{\up $}{\footnote {\up $} OnZipComplete Event }
{\up +}{\footnote {\up +} vclzip:000230}
{\up K}{\footnote {\up K} Events;OnZipComplete;}
{\up A}{\footnote {\up A} TVCLZip_OnZipComplete;OnZipComplete_Event;OnZipComplete}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnZipComplete Event 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnZipComplete: TZipComplete = \b procedure\b0 (Sender: TObject; FileCount: Integer); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnZipComplete event handler is triggered at the very end of an Zip process, after ALL files have beenzipped. Note that this event is not triggered after each file is zipped.  For that you would use the \strike OnEndZip Event\strike0\fs24{\v Scribble3470}\fs22 .  
\par 
\par The FileCount parameter that is passed into the event contains the total number of files that were successfully unzipped. 
\par  
\par This event will rarely be used since the same information can be obtained from the return value from the call to the \strike Zip Method\strike0\fs24{\v Scribble3405}\fs22 .  This event is mainly can be useful when using VCLZip in threads where in certain circumstances the return from the Zip method is not seen. 
\par  
\par See Also: 
\par  
\par \strike OnUnZipComplete Event\strike0\fs24{\v Scribble2535}\fs22 
\par  \strike OnEndZip Event\strike0\fs24{\v Scribble3470}\fs22   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3320}
{\up $}{\footnote {\up $} PackLevel property}
{\up +}{\footnote {\up +} vclzip:000240}
{\up K}{\footnote {\up K} Compression Level;PackLevel;}
{\up A}{\footnote {\up A} TVCLZip_PackLevel;PackLevel_Property;PackLevel}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 PackLevel property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  PackLevel: Integer;\f2    Default = 6\f3 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The PackLevel property determines how hard the compression algorighm will try to compress files.  This property can be given a value from 0 through 9.  A value of 0 is no compression at all (STORED) which is useful for adding things like other zip files (which will compress very little if any) to an archive.  A value of 1 will compress the fastest, but the compression ratio will be the lowest.  A value of 9 will compress the slowest, but the compression ratio will be the highest.
\par   
\par You may specify particular files that you do not want VCLZip to try to compress by adding their filespecs or wildcards to the \strike NoCompressList\strike0\fs24{\v Scribble3285}\fs22 .  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3330}
{\up $}{\footnote {\up $} PreserveStubs property}
{\up +}{\footnote {\up +} vclzip:000250}
{\up K}{\footnote {\up K} PreserveStubs;}
{\up A}{\footnote {\up A} TVCLZip_PreserveStubs;PreserveStubs_Property;PreserveStubs}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 PreserveStubs property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  PreserveStubs: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If PreserveStubs is True, then when opening an SFX archive (self extracting archive) as a zip file and making changes to it (i.e. adding or deleting files), the archive will remain an SFX Archive (in other words, the sfx stub at the beginning of the archive will be preserved).  If PreserveStubs is False, then when making any modifications at all to an SFX archive, the archive will be converted back to a regular zip archive.  
\par 
\par The default value for PreserveStubs is False, mainly to preserve backward compatability. 
\par  
\par PreserveStubs is a public property. 
\par  
\par \cf1\b IMPORTANT:\cf0\b0  If the sfx archive that you are working with contains any internal checks for the size of the archive then modifying the file may cause the sfx executable to no longer work. 
\par  
\par See Also: 
\par  
\par \strike MakeSFX Method\strike0\fs24{\v Scribble3440}\fs22  
\par \strike Creating a Self Extracting Zip File\strike0\fs24{\v PG174}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 Run-time only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3335}
{\up $}{\footnote {\up $} Recurse property}
{\up +}{\footnote {\up +} vclzip:000260}
{\up K}{\footnote {\up K} Paths;Recurse;}
{\up A}{\footnote {\up A} TVCLZip_Recurse;Recurse_Property;Recurse}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Recurse property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Recurse: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Recurse property determines whether subdirectories will be recursed to look for files to be compressed when zipping with a wildcard mask.  Set to true if you wish subdirectories to be traversed.  
\par If this value is set to True, and a wildcard mask is specified in the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  without any path information, then the value of the \strike RootDir Property\strike0\fs24{\v Scribble2580}\fs22  will determine which directory zipping will start in.  Results may be unexpected or even bad if you do not supply path information either in the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  or the \strike RootDir Property\strike0\fs24{\v Scribble2580}\fs22 . 
\par  
\par \cf1\b NOTE:  Overriding the Recurse Propery\f1  for some FilesList entries:\cf0\b0\f0   
\par By adding the following characters to the beginning of the filenames being added to the FilesList, you can override whatever the current setting is for the RECURSE property:  
\par 
\par \pard\li360\cf4 '>' will force recursion into subdirectories '|' will force NO-recursion  
\par \cf0 
\par \pard For instance: 
\par  
\par \pard\li240\cf4 VCLZip1.FilesList.add('>c:\\windows\\*.ini'); 
\par \cf0  
\par \pard will get all .ini files in and below the windows directory reguardless of what the recurse property setting is.  
\par and:  
\par 
\par \pard\li240\cf4 VCLZip1.FilesList.add('|c:\\windows\\sys*\\*.dll'); 
\par \cf0  
\par \pard will get all .dll files in subdirectories of the windows directories that start with 'sys' but will not recurse into any directories below the sys* directories.
\par   
\par It is important to note that this is only useful for zipping, not unzipping operations.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3340}
{\up $}{\footnote {\up $} RelativePaths property}
{\up +}{\footnote {\up +} vclzip:000270}
{\up K}{\footnote {\up K} Paths;RelativePaths;}
{\up A}{\footnote {\up A} TVCLZip_RelativePaths;RelativePaths_Property;RelativePaths}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 RelativePaths property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  RelativePaths: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The RelativePaths property should be set to True if you wish to save path information but only wish to save path information relative to a specified directory.  The only path information that is saved is for subdirectories below the specified directory.  This is similar to the Relative Path option of PKZip for Windows. 
\par  
\par Whenever you set RelativePaths property to True, the \strike Recurse Property\strike0\fs24{\v Scribble3335}\fs22  and the \strike StorePaths Property\strike0\fs24{\v Scribble3360}\fs22  are automatically set to True also.  Likewise, if the StorePaths Property is set to False, then the RelativePaths Property is automatically set to False also.  
\par 
\par You would normally use a wildcard to specify files to be zipped, but you may also add specific files to the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  as long as they are within the directory tree of the \strike RootDir\strike0\fs24{\v Scribble2580}\fs22 .  
\par 
\par If you add to, or replace files in, an existing archive which was created with the relative path option you should set the RootDir property to the same value that was used when the archive was created before calling the Zip method.  
\par When storing relative paths it is \cf1\b NECESSARY\cf0\b0  to use the \strike RootDir Property\strike0\fs24{\v Scribble2580}\fs22  to specify the directory in which to start the recursive search for files to compare to some wildcard filespec.  Here is an example of using the RelativePaths property: 
\par 
\par \cf4 With VCLZip1 do 
\par \pard\li120 begin 
\par \pard\li360 ZipName := 'c:\\backups\\MyArchive.Zip'; 
\par \pard\li360\tx4200 RootDir := 'c:\\develop\\myprog\\';\tab /* Set the starting directory */ 
\par FilesList.Add('*.pas');\tab /* Don't include path here */ 
\par RelativePaths := True;\tab /* Specify Relative Paths - sets StorePaths & Recurse to True also*/ 
\par \pard\li360 Zip; 
\par \pard\li120 end; 
\par 
\par \pard\cf0 Say the directory structure looks something like the following:  
\par \pard\li360\\develop\\myprog 
\par \\develop\\myprog\\help 
\par \\develop\\myprog\\examples 
\par \\develop\\myprog\\proj 
\par \\develop\\myprog\\proj\\save
\par  
\par \pard Files zipped from each of these directories will have the following path information stored depending on how RelativePaths is set: 
\par  
\par \pard\fi-3000\li3000\tx3000\tx720\cf4\ul RelativePaths = False\ulnone\tab\ul RelativePaths = True\cf0\ulnone  
\par develop\\myprog\\\tab None Saved  
\par \pard\fi-3000\li3000\tx3000 develop\\myprog\\help\\\tab help\\ 
\par develop\\myprog\\examples\\\tab examples\\ 
\par develop\\myprog\\proj\\\tab proj\\ 
\par develop\\myprog\\proj\\save\\\tab proj\\save\\ 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3345}
{\up $}{\footnote {\up $} ResetArchiveBitOnZip property}
{\up +}{\footnote {\up +} vclzip:000280}
{\up K}{\footnote {\up K} ResetArchiveBitOnZip;}
{\up A}{\footnote {\up A} TVCLZip_ResetArchiveBitOnZip;ResetArchiveBitOnZip_Property;ResetArchiveBitOnZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ResetArchiveBitOnZip property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ResetArchiveBitOnZip: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setting this to True will cause the Archive Bit for each file to be reset (turned off) after being zipped. 
\par  
\par \cf1\b NOTE: \cf0\b0 Be sure to see \strike SkipIfArchiveBitNotSet\strike0{\v Scribble3350} as that property will control whether or not files are archived if their archive bit is not set.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3350}
{\up $}{\footnote {\up $} SkipIfArchiveBitNotSet property}
{\up +}{\footnote {\up +} vclzip:000290}
{\up K}{\footnote {\up K} SkipIfArchiveBitNotSet;}
{\up A}{\footnote {\up A} TVCLZip_SkipIfArchiveBitNotSet;SkipIfArchiveBitNotSet_Property;SkipIfArchiveBitNotSet}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SkipIfArchiveBitNotSet property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  SkipIfArchiveBitNotSet: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setting this to True will cause files that do not have their Archive Bit set (turned on) to be skipped during zip operations.  Therefore, while this is set to True, only files with their Archive attribute turned on will be zipped. 
\par  
\par \cf1\b NOTE: \cf0\b0 Be sure to see \strike ResetArchiveBitOnZip\strike0{\v Scribble3345} as that property (if set to True) will reset the archive bit for each file that is zipped.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3355}
{\up $}{\footnote {\up $} Store83Names property}
{\up +}{\footnote {\up +} vclzip:000300}
{\up K}{\footnote {\up K} Store83Names;}
{\up A}{\footnote {\up A} TVCLZip_Store83Names;Store83Names_Property;Store83Names}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Store83Names property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Store83Names: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 When set to True, this will force any long file and pathnames to be stored in DOS 8.3 format.  This is useful if you plan to unzip the files onto a WIN3.X system where long filenames are not valid.  Note however, that VCLUnZip will handle unzipping long filenames to a WIN3.X system properly by shortening the filenames at the time of extraction.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3360}
{\up $}{\footnote {\up $} StorePaths property}
{\up +}{\footnote {\up +} vclzip:000310}
{\up K}{\footnote {\up K} Paths;StorePaths;}
{\up A}{\footnote {\up A} TVCLZip_StorePaths;StorePaths_Property;StorePaths}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 StorePaths property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  StorePaths: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The StorePaths property, if set to True, will cause path information to be stored with the zip entry. If the \strike StoreVolumes Property\strike0{\v Scribble3365} is set to True then the entire path will be stored.  If the StoreVolumes Property is False, then only the path information will be stored.
\par   
\par If StorePaths is False, then only the filename itself is stored.  
\par 
\par Note that if the \strike RelativePaths Property\strike0{\v Scribble3340} is set to True, then this StorePaths property will automatically be set to True also.  Likewise, if the StorePaths property is ever set to False, then both the RelativePaths and the \strike StoreVolumes Property\strike0{\v Scribble3365} will automatically be set to False.  
\par 
\par The following shows the results, assuming StorePaths is True: 
\par  
\par \pard\li240\tx2640\tx6300\cf4\b StoreVolumes\f1\tab\f0 Filename\f1\tab\f0 Stored Result  
\par \b0 True\f1\tab\f0 C:\\DIRECTORY\\FILENAME.EXT\f1\tab\f0 C:\\DIRECTORY\\FILENAME.EXT 
\par False\f1\tab\f0 C:\\DIRECTORY\\FILENAME.EXT\f1\tab\f0 DIRECTORY\\FILENAME.EXT
\par \pard\li720\cf0   
\par \pard The \strike RelativePaths Property\strike0{\v Scribble3340} will also affect what is stored for the path information.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3365}
{\up $}{\footnote {\up $} StoreVolumes property}
{\up +}{\footnote {\up +} vclzip:000320}
{\up K}{\footnote {\up K} Paths;StoreVolumes;}
{\up A}{\footnote {\up A} TVCLZip_StoreVolumes;StoreVolumes_Property;StoreVolumes}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 StoreVolumes property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  StoreVolumes: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The StoreVolumes property determines whether volume information is stored along with the filename within the zip file when files are zipped.  This is useful when making backups into a zip file when the files are from different volumes.  It will make it easier to restore files later, or to make new backup zip files based on the same zip file entries.  Volume information (i.e. C:\\) will be saved if this property is set to True.  
\par 
\par \cf1\b IMPORTANT!!!: \cf0\b0 Setting this property to True will cause the resulting archive to \cf1\b NOT be PKZip compatible\cf0\b0 .  This is the only property which will have this effect. While VCLZip will be able to correctly unzip files that have volume information stored, other zip utilities and components most likely will have problems with it.  So, if you wish to maintain complete PKZip compatibility, please do not use this property!  
\par  
\par \fs24 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3370}
{\up $}{\footnote {\up $} TempPath property}
{\up +}{\footnote {\up +} vclzip:000330}
{\up K}{\footnote {\up K} TempPath;}
{\up A}{\footnote {\up A} TVCLZip_TempPath;TempPath_Property;TempPath}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 TempPath property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  TempPath: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 By default temporary files are created in the system's directory that is defined by the TEMP environment variable. However, in certain situations you may want to direct temporary files to be created somewhere else.  For instance if you are adding files to a large archive, the modified archive is first created as a temporary file.  As long as everything finishes ok then the original archive is replaced by the temporary archive.  If you do not have enough disk space where your default TEMP directory resides, then you may set the TempPath property to a directory where you do have ample disk space available.  
\par 
\par \cf1 IMPORTANT:\cf0  As of VCLZip 2.21, if the temporary file is on the same disk as the zip file that you are working with, it will be renamed instead of copied, resulting in faster processing for large zip files.  So, while offloading the TempPath to another disk is necessary if disk space is low, having the TempPath on the same drive as zip files that you are ADDING files to will be faster.  
\par 
\par You may set this property in either the Object Inspector or within the source code.
\par   
\par \cf4 Example:  
\par \tab TempPath := 'd:\\mytemp';  /* all temporary files will now be created in d:\\mytemp */ \cf0   
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3375}
{\up $}{\footnote {\up $} ZipAction property}
{\up +}{\footnote {\up +} vclzip:000340}
{\up K}{\footnote {\up K} ZipAction;}
{\up A}{\footnote {\up A} TVCLZip_ZipAction;ZipAction_Property;ZipAction}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipAction property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  ZipAction: TZipAction = (zaUpdate, zaReplace, zaFreshen);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipAction property determines whether files will be replaced in a zip or not.  If ZipAction is set to zaUpdate then a zip entry will only be replaced if the disk file is newer than the zip entry.  If ZipAction is set to zaReplace, then the zip entry will be replaced by the disk file regardless of the file dates.  A ZipAction of zaFreshen is the same as zaUpdate, except that filenames that do not match any entries already in the zip file will be ignored and not added to the zip. 
\par  
\par \cf1 IMPORTANT: \cf0 When replacing files in an already existing archive, matching files on your hard drive with what is in the archive is dependant on how the \strike StorePaths Property\strike0\fs24{\v Scribble3360}\fs22  and the \strike RelativePaths Property\strike0\fs24{\v Scribble3340}\fs22  are set.  These properties should be set exactly the same as they were when the archive was originally created. The reason for this is that path information is used when comparing a file that is being zipped to the files that are already in the archive.
\par   
\par \cf1 Also, be sure to include kpZipObj in your USES list when using this property.  
\par \cf0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3385}
{\up $}{\footnote {\up $} DeleteEntries method}
{\up +}{\footnote {\up +} vclzip:000350}
{\up K}{\footnote {\up K} DeleteEntries;}
{\up A}{\footnote {\up A} TVCLZip_DeleteEntries;DeleteEntries_Method;DeleteEntries}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DeleteEntries method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  DeleteEntries: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The DeleteEntries method deletes entries from the zip file specified by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22 .  
\par Files are deleted in one of two ways: 
\par  
\par 1) use the \strike Selected\strike0\fs24{\v Scribble2585}\fs22  property to select the files you wish to delete before calling DeleteEntries.  
\par 2) Put filenames and/or wildcard specifications into the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22 .  Any files within the zip file that match any of the specified files or wildcard masks within the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  will be removed from the zip file.  
\par 
\par You cannot combine these two methods in one call to DeleteEntries.  If any files have had their \strike Selected\strike0\fs24{\v Scribble2585}\fs22  property set to True, then the FilesList will be cleared before processing the delete operation. 
\par  
\par \b Return Value  
\par \b0 The return value specifies the actual number of entries deleted from the zip file.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3390}
{\up $}{\footnote {\up $} FixZip method}
{\up +}{\footnote {\up +} vclzip:000360}
{\up K}{\footnote {\up K} FixZip;}
{\up A}{\footnote {\up A} TVCLZip_FixZip;FixZip_Method;FixZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 FixZip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  FixZip(InputFile, OutputFile: \b string\b0 ): Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The FixZip method will attempt to read a zip file that has been truncated and save a complete zip file.  This will save as many compressed files as is possible.
\par   
\par Also, the integrity of each file is tested using the \strike FileIsOK Property\strike0\fs24{\v Scribble2415}\fs22 , and any files that return False for this property will not be included in the Fixed archive.  
\par 
\par \b Return Value  
\par \b0 The return value is the number of compressed file entries in the resulting "fixed" file.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3395}
{\up $}{\footnote {\up $} MakeNewSFX method}
{\up +}{\footnote {\up +} vclzip:000370}
{\up K}{\footnote {\up K} MakeNewSFX;SFX;}
{\up A}{\footnote {\up A} TVCLZip_MakeNewSFX;MakeNewSFX_Method;MakeNewSFX}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 MakeNewSFX method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  MakeNewSFX(SFXStub: \b string\b0 ; FName: \b string\b0 ; Options: PChar; OptionsLen: Integer): Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This method allows you to create a new Self Extracting Zip File without requiring the in between step of creating a zip file first.  (To make an SFX from an existing zip file, see the \strike MakeSFX Method\strike0\fs24{\v Scribble3440}\fs22 )  The contents of the zip file will be created using the contents of the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22 ,  just as it is used when creating a new regular zip file, and/or a the contents of a zip file specified in the FName paramter (see below).  
\par 
\par \b SFXStub\b0  is the filename of the SFX stub file that is to be used to create the SFX.  
\par 
\par \b FName\b0  is the filename of the resulting SFX file that is to be created, for instance 'MYSFX.EXE'.  If this filename is, instead, the name of an already existing zip file (.i.e. 'MYSFX.ZIP'), then the files in this zip file will be included in the resulting SFX file. This is in addition to any files that may be specified in the FilesList.  The name of the resulting SFX file in this case will be the same as the zip file except with an extention of .EXE.
\par   
\par \b Options and OptionsLen\b0 : 
\par This method is designed to work well with the 32bit SFX stub that is supplied with VCLZip (ZIPSFX32.BIN) configurable by adding a configuation block between the stub and zip file.   The Options and OptionsLen parameters are specifically for this purpose.  Options should point at the options memory block (remember to cast as a PChar) and OptionsLen should be set to the length of that block in bytes.  If you do not have an options block, or your stub is not compatible with the options block, just set the Options parameter to nil and set OptionsLen to zero.
\par   
\par The return value is the number of files that were successfully zipped into the SFX file.  
\par 
\par Additionally, if you use the \strike TSFXConfig Component\strike0\fs24{\v Scribble4010}\fs22 , along with the 32bit SFX stub that is distributed with VCLZip, this allows you to easily create a configurable 32bit SFX.  The Options and OptionsLen values are set for you and other options are easy to set:  See \strike TSFXConfig\strike0\fs24{\v Scribble4010}\fs22  for an example. 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3400}
{\up $}{\footnote {\up $} Split method}
{\up +}{\footnote {\up +} vclzip:000380}
{\up K}{\footnote {\up K} Split;}
{\up A}{\footnote {\up A} TVCLZip_Split;Split_Method;Split}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Split method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  Split(DeleteOriginal: boolean): boolean;
\par \f7 
\par \b\fs22 Description
\par \b0\f6\fs20 Call Split to take a normal zip archive and split it into blocks, just as if you originally created the zip file with MultiZipInfo.\cf2\strike multimode\cf3\strike0{\v Scribble2465}\cf0  := mmBlocks;  Set all the properties as if you are about to create a \cf2\strike Blocked Zip File\cf3\strike0{\v PG2} and then call this.
\par 
\par Setting DeleteOriginal to True will cause the archive that you just split into parts to be deleted when the operatoin is finished.\cf0\f7 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3405}
{\up $}{\footnote {\up $} Zip method}
{\up +}{\footnote {\up +} vclzip:000390}
{\up K}{\footnote {\up K} Compress;Zip;}
{\up A}{\footnote {\up A} TVCLZip_Zip;Zip_Method;Zip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Zip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  Zip: Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The Zip method compresses files into the zip file specified by the property \strike ZipName\strike0\fs24{\v Scribble2615}\fs22 .  Prior to calling this method you should add appropriate filenames and wildcards to the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22  property.  If ZipName is an archive that already exists, the files in FilesList will be added to that archive.  Therefore if the archive already exists and you wish to create a new archive by the same name you will have to delete the original archive first. 
\par  
\par \b Return Value\b0   
\par The return value is the actual number of files that were added to the zip file.  This may differ from the number of files that you added to the \strike FilesList\strike0\fs24{\v Scribble2425}\fs22 .  For instance if you added a file to the list that didn't actually exist.  Also, wildcards will normally expand the list to include more files.  If a file is skipped, for instance because there is no such file, then the \strike OnSkippingFile Event\strike0\fs24{\v Scribble2520}\fs22  will be called, if it has been assigned.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3410}
{\up $}{\footnote {\up $} ZipFromBuffer method}
{\up +}{\footnote {\up +} vclzip:000400}
{\up K}{\footnote {\up K} Buffers;Compress;Zip;ZipFromBuffer;}
{\up A}{\footnote {\up A} TVCLZip_ZipFromBuffer;ZipFromBuffer_Method;ZipFromBuffer}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipFromBuffer method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  ZipFromBuffer(Buffer: PChar; Amount: Longint; FName: \b string\b0 ): Integer;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipFromBuffer method allows you to zip information directly from a memory buffer specified by the \b Buffer\b0  parameter. The length of the buffer MUST be specified in the \b Amount\b0  parameter.  The filename information that should be stored with the file in the archive must be passed in the \b FName\b0  parameter.
\par   
\par \b Return Value  
\par \b0 The return value will be 1 if the buffer was zipped and 0 if it was not successfully zipped. 
\par  
\par As an example of using ZipFromBuffer, you might use it to directly zip the contents of a TMemo component such as: 
\par 
\par \cf4     Zipper.ZipFromBuffer(PChar(TextMemo.Lines.Text), Length(TextMemo.Lines.Text), CurrentFile);\cf0  
\par \b 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b0\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3415}
{\up $}{\footnote {\up $} ZipFromStream method}
{\up +}{\footnote {\up +} vclzip:000410}
{\up K}{\footnote {\up K} Compress;Streams;Zip;ZipFromStream;}
{\up A}{\footnote {\up A} TVCLZip_ZipFromStream;ZipFromStream_Method;ZipFromStream}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ZipFromStream method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 function\b0  ZipFromStream(theStream: TkpStream; FName: \b string\b0 ): Integer;\f2  \b overload\b0 ;\f3 
\par \b function\b0  ZipFromStream(theStream: TkpStream; FName: \b string\f2 ; \b0 FreeStreamWhenDone: Boolean\f3 ): Integer;\f2  \b overload\b0 ;\f3 
\par \f6 // D4,D5,BCB4,BCB5 only...\f7 
\par \b\f3 function\b0  ZipFromStream(theStream: TStream; FName: \b string\f2 ; \b0 FreeStreamWhenDone: Boolean\f3 ): Integer;\f2  \b overload\b0 ;\f3 
\par \f7 
\par 
\par \b\fs22 Description
\par \pard\b0\f0 The ZipFromStream method will take theStream, and zip it to the zip file specified by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\f1  or to the \cf2\strike ArchiveStream\cf3\strike0{\v Scribble2310}\cf0\f0\fs22 .  This allows you to, for instance, take a currently open T\f1 Memory\f0 Stream and save it directly to a zip file without having to first save it to a disk file.  All of the VCLZip's current properties will affect the processing of the file.  FName specifies the filename that will be given to the saved file.  If the \strike StorePaths Property\strike0\fs24{\v Scribble3360}\fs22  is set to True, then path information will be saved if FName includes path information.
\par 
\par \f1 The FreeStreamWhenDone parameter tells VCLZip to free the stream when it has finished zipping the stream into the archive. If it is false, or if you use the overloaded ZipFromStream that does not include this parameter, then it is left up to your application to free the stream.  It is most useful to set this to True if you are using the OnGetNextStream event to have VCLZip zip multiple streams into the archive in one operation.\f0  
\par 
\par \f1 If you have defined an \cf2\strike OnGetNextStream \cf3\strike0{\v Scribble3475}\cf0 event, it will be called to get more streams to zip into the same archive.
\par 
\par The overloaded version of this method that is for D4, D5, BCB4, and BCB5 only is to allow these versions of Delphi/BCB to zip from a normal TStream rather than a TkpStream.  \cf1 Note that in D6, D7, and BCB6, TkpStream = TStream as these versions of Delphi/BCB have Int64 capabilities in TStream.
\par \f0 
\par \cf0\b Return Value  
\par \b0 The return value will be 1 if the stream was zipped and 0 if it was not successfully zipped.  \f1 If OnGetNextStream is defined then the return value will be the total number of streams zipped.\f0 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3425}
{\up $}{\footnote {\up $} ExpandFilesList method}
{\up +}{\footnote {\up +} vclzip:000420}
{\up K}{\footnote {\up K} ExpandFilesList;}
{\up A}{\footnote {\up A} TVCLZip_ExpandFilesList;ExpandFilesList_Method;ExpandFilesList}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 ExpandFilesList method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  ExpandFilesList(\b var\b0  NumFiles: Integer; \b var\b0  TotalBytes: Comp);
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \f6 Call this just to see what the FilesList will look like when all wildcards have been expanded.  At this time, When you call Zip or UnZip after this, the FilesList will still be processed again, but of course no wildcards will have to be resolved.  This gives you a chance to see exactly what will be zipped or unzipped and let you change what's in the FilesList before actually processing.
\par \f7 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3440}
{\up $}{\footnote {\up $} MakeSFX method}
{\up +}{\footnote {\up +} vclzip:000430}
{\up K}{\footnote {\up K} MakeSFX;SFX;}
{\up A}{\footnote {\up A} TVCLZip_MakeSFX;MakeSFX_Method;MakeSFX}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 MakeSFX method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  MakeSFX(SFXStub: \b string\b0 ; ModHeaders: Boolean);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Call this method to turn the current zip file (defined by the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22 ) into a self extracting zip file. Use your own sfx stub or you may use one of the ones supplied by VCLZip (find them with the Zip Utility Example project file). Specify the path and filename of the SFX Stub that you wish to use in the SFXStub parameter.  If ModHeaders is defined as \cf4 True\cf0 , then the zip file header location pointers will be adjusted to compensate for the stub that is added to the beginning of the file.  If ModHeaders is \cf4 False\cf0 , then the headers will not be adjusted.  
\par 
\par \cf1 NOTE:\cf0   At this time, the value of ModHeaders will be considered to be True no matter what you define it to be.  The headers will always be adjusted.  The capability to \b NOT\b0  adjust headers will be available in a later release.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3445}
{\up $}{\footnote {\up $} SaveModifiedZipFile method}
{\up +}{\footnote {\up +} vclzip:000440}
{\up K}{\footnote {\up K} SaveModifiedZipFile;}
{\up A}{\footnote {\up A} TVCLZip_SaveModifiedZipFile;SaveModifiedZipFile_Method;SaveModifiedZipFile}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SaveModifiedZipFile method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  SaveModifiedZipFile;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The SaveModifiedZipFile method saves a zip file that is currently in the modified state (See the \strike IsModified\strike0\fs24{\v Scribble3270}\fs22   Property).  At this time, the actions that will leave a zip file in the modified state are by  
\par 
\par \pard\fi-360\li360\tx360\f1\bullet\tab\f0 Adding or modifying a \strike ZipComment Property\strike0\fs24{\v Scribble2605}\fs22  or any number of \strike FileComments\strike0\fs24{\v Scribble2405}\fs22 .  
\par \f1\bullet\tab\f0 Writing to any number of \strike Pathname Properties\strike0\fs24{\v Scribble2555}\fs22   
\par \f1\bullet\tab\f0 Writing to any number of \strike Filename Properties\strike0\fs24{\v Scribble2420}\fs22  
\par  
\par \pard Also, anytime that a currently modified zip file is open and the \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  is changed, or the zip file is closed, then the zip file will be saved before continuing.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3450}
{\up $}{\footnote {\up $} SFXToZip method}
{\up +}{\footnote {\up +} vclzip:000450}
{\up K}{\footnote {\up K} SFXToZip;}
{\up A}{\footnote {\up A} TVCLZip_SFXToZip;SFXToZip_Method;SFXToZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 SFXToZip method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  SFXToZip(DeleteSFX: Boolean);
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This will convert an sfx archive to a regular zip archive.  If you want to delete the original sfx file when the conversion is done, then set DeleteSFXFile to True.   The \strike ZipName Property\strike0\fs24{\v Scribble2615}\fs22  must be set to the SFX file that you wish to convert first.  
\par 
\par All header pointers will be properly adjusted during the conversion.  
\par 
\par When the conversion is done, the current archive, ZipName, will be set to the newly created ZIP file.  
\par 
\par \cf4 Example:  
\par \pard\li240 VCLZip1.ZipName := 'c:\\mydirectory\\SomeSFX.EXE';  // Set the SFX file to be converted 
\par VCLZip1.ReadZip;  // Cause VCLZip to read the contents of the file 
\par VCLZip1.SFXToZip(True);  // Convert the SFX to a regular ZIP file and delete the old SFX file. 
\par \pard\cf0   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3455}
{\up $}{\footnote {\up $} OnDeleteEntry event}
{\up +}{\footnote {\up +} vclzip:000460}
{\up K}{\footnote {\up K} Events;OnDeleteEntry;}
{\up A}{\footnote {\up A} TVCLZip_OnDeleteEntry;OnDeleteEntry_Event;OnDeleteEntry}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnDeleteEntry event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnDeleteEntry: TDeleteEvent = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ; \b var\b0  Skip: Boolean); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Define this event if you wish to perform your own encryption and decryption instead of the normal pkzip encryption. Use this with care as this is still somewhat experimental and I'm not sure how useful it is yet.  You must make all changes within the buffer sent in to you.  Treat the entire file as a stream.  Byte for byte replacement only. No additional keys can be saved.
\par   
\par The buffer pointer that is passed in, points to  the data that is to be Decrypted.  The length (in bytes) of the buffer is passed in in the length parameter.  Do not change the buffer pointer.  Do not change the length of the buffer in any way. Essentially all that is allowed is a byte for byte replacement within the buffer.  The Password parameter contains whatever is in the \strike Password Property\strike0\fs24{\v Scribble2550}\fs22 .  
\par 
\par See Also:
\par   
\par \strike OnEncrypt\strike0\fs24{\v Scribble3465}\fs22  
\par \strike Password\strike0\fs24{\v Scribble2550}\fs22  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3460}
{\up $}{\footnote {\up $} OnDisposeFile event}
{\up +}{\footnote {\up +} vclzip:000470}
{\up K}{\footnote {\up K} Events;OnDisposeFile;}
{\up A}{\footnote {\up A} TVCLZip_OnDisposeFile;OnDisposeFile_Event;OnDisposeFile}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnDisposeFile event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnDisposeFile: TDisposeEvent = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ; \b var\b0  Skip: Boolean); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnDisposeFile event handler is executed for each file, just before it is about to be deleted from disk. This will only happen if you have set the \strike Dispose Property\strike0\fs24{\v Scribble3225}\fs22  to True causing each file that has been compressed to be deleted from disk, effectively "moving" the files from disk into the zip file.  No files are actually deleted until the zip file has been successfully created.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3465}
{\up $}{\footnote {\up $} OnEncrypt event}
{\up +}{\footnote {\up +} encryption:000050}
{\up K}{\footnote {\up K} Encryption;Events;OnEncrypt;Password;}
{\up A}{\footnote {\up A} TVCLZip_OnEncrypt;OnEncrypt_Event;OnEncrypt}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnEncrypt event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnEncrypt: TEncryptEvent = \b procedure\b0 (Sender: TObject; buffer: BytePtr; length: Integer; Password: \b string\b0 ); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Define this event if you wish to perform your own encryption instead of the normal pkzip encryption.  Use this with care as this is still somewhat experimental and I'm not sure how useful it is yet.  You must make all changes within the buffer sent in to you.  Treat the entire file as a stream.  Byte for byte replacement only. No additional keys can be saved. 
\par  
\par The buffer pointer that is passed in, points to  the data that is to be encrypted.  The length (in bytes) of the buffer is passed in in the length parameter.  Do not change the buffer pointer.  Do not change the length of the buffer in any way. Essentially all that is allowed is a byte for byte replacement within the buffer.  The Password parameter contains whatever is in the \strike Password Property\strike0\fs24{\v Scribble2550}\fs22 .  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3470}
{\up $}{\footnote {\up $} OnEndZip event}
{\up +}{\footnote {\up +} vclzip:000490}
{\up K}{\footnote {\up K} Events;OnEndZip;}
{\up A}{\footnote {\up A} TVCLZip_OnEndZip;OnEndZip_Event;OnEndZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnEndZip event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnEndZip: TEndZipFileEvent = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ; UncompressedSize, CompressedSize, CurrentZipSize: LongInt); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnEndZip event handler is triggered just after each file has been compressed. 
\par  
\par \b Parameters  
\par \cf4\b0 FName \cf0 = the filename of the file that was just compressed. 
\par \cf4 UnCompressedSize \cf0 = the normal size of the file that was just compressed. 
\par \cf4 CompressedSize \cf0 = the size of the compressed entry in the zip file. 
\par \cf4 CurrentZipSize \cf0 = the size of the zip file right after this file was added. 
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3475}
{\up $}{\footnote {\up $} OnGetNextStream event}
{\up +}{\footnote {\up +} vclzip:000500}
{\up K}{\footnote {\up K} Events;OnGetNextStream;Streams;}
{\up A}{\footnote {\up A} TVCLZip_OnGetNextStream;OnGetNextStream_Event;OnGetNextStream}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnGetNextStream event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnGetNextStream: TOnGetNextStreamEvent = \b procedure\b0 (Sender: TObject; \b var\b0  stream: TKPStream; \b var\b0  NextFileName: \b String\b0 ); \b of\b0  \b object\b0 ;
\par 
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \f6 This event allows you to pass in additional streams to be zipped when calling \cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf0 . If this is not defined, then ZipFromStream will only zip one stream.  This event makes it much more efficient to zip multiple streams into one archive because it does it all in one process.  The alternative is to call ZipFromStream multiple times which results in modifying an existing archive for all but the first call to ZipFromStream.  This would mean that the zip file is recreated each time.
\par \f7 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3478}
{\up $}{\footnote {\up $} OnGetNextTStream event}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnGetNextTStream event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnGetNext\f2 T\f3 Stream: TOnGetNext\f2 T\f3 StreamEvent;
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 
\par \cf1\f6 NOTE: This event is only defined, and only needed, for D4, D5, BCB4, and BCB5. (The method you should use for D6, D7, and BCB6 is \cf2\strike OnGetNextStream \cf3\strike0{\v Scribble3475})\cf1  OnGetNextTStream allows you to pass in TStreams instead of TkpHugeStreams.  This is a convenience event to make it easier for these versions of Delphi/BCB to work with TStreams.  Just keep in mind that this means that the stream passed in cannot be larger than 2 gigs in size since in these versions of Delphi/BCB, TStreams cannot handle sizes greater than 2 gig.\cf0\f7 
\par 
\par \f6 This event allows you to pass in additional streams to be zipped when calling \cf2\strike ZipFromStream\cf3\strike0{\v Scribble3415}\cf0 . If this is not defined, then ZipFromStream will only zip one stream.  This event makes it much more efficient to zip multiple streams into one archive because it does it all in one process.  The alternative is to call ZipFromStream multiple times which results in modifying an existing archive for all but the first call to ZipFromStream.  This would mean that the zip file is recreated each time.
\par \f7 
\par \pard 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3480}
{\up $}{\footnote {\up $} OnNoSuchFile event}
{\up +}{\footnote {\up +} vclzip:000510}
{\up K}{\footnote {\up K} Events;OnNoSuchFile;}
{\up A}{\footnote {\up A} TVCLZip_OnNoSuchFile;OnNoSuchFile_Event;OnNoSuchFile}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnNoSuchFile event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnNoSuchFile: TNoSuchFileEvent = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnNoSuchFile event handler is triggered when you have entered a file into the \strike FilesList Property\strike0\fs24{\v Scribble2425}\fs22  zipped and there is no such file. 
\par  
\par \b Parameters  
\par \b0 FName = the filename of the file that was added to the FilesList that does not exist. 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3485}
{\up $}{\footnote {\up $} OnStartZip event}
{\up +}{\footnote {\up +} vclzip:000520}
{\up K}{\footnote {\up K} Events;OnStartZip;}
{\up A}{\footnote {\up A} TVCLZip_OnStartZip;OnStartZip_Event;OnStartZip}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnStartZip event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnStartZip: TStartZipEvent = \b procedure\b0 (Sender: TObject; FName: \b string\b0 ; \b var\b0  ZipHeader: TZipHeaderInfo; \b var\b0  Skip: Boolean); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnStartZip event handler is executed when a file is about to be compressed.  This gives you a chance to convey information to the user, skip this particular file, or even modify some of the information that is stored along with it in the archive.  
\par 
\par \cf1 IMPORTANT: \cf0 Be sure to include kpZipObj in your USES list if you plan on using this event!  It has the required definition of the ZipHeaderInfo object. 
\par  
\par \b Parameters  
\par FName: \b0 The filename of the file about to be compressed including the full path. 
\par 
\par \b Skip:\b0   Set this to True if you do not wish to compress this file.  This is useful if you want to avoid zipping certain files. Say for instance you don't want to zip files with the extention '.TMP'.  You could check FName to see if it's extention is '.TMP' and if so, set Skip to True.  No '.TMP' files will be zipped. 
\par 
\par \b ZipHeader:\b0  This object contains all of the information for this file that will go into the archive.  You may change this information but you must be careful because you could corrupt the archive if you try to do things that you shouldn't. If you stick to changing only the following information you will be safe:  
\par 
\par \pard\fi-5400\li5400\tx5400\tx720\cf4 ZipHeader.Filename\tab\cf0 Change this file's Filename (in the archive)  
\par \cf4 ZipHeader.Pathname\tab\cf0 Change this file's path information  
\par \cf4 ZipHeader.SetDateTime( DateTime: TDateTime )\tab\cf0 Change the timestamp for this file  
\par \cf4 ZipHeader.SetNewFileComment( NewComment: String )\tab\cf0 Add a comment for this file 
\par  
\par \pard For example in your OnStartZip event you may wish to do something like the following: 
\par  
\par \cf4\f8 procedure MyForm.OnStartZip( Sender: TObject; FName: String;  var ZipHeader: TZipHeaderInfo; var Skip: Boolean ); 
\par begin 
\par \pard\li360\tx6000 If UpperCase(ExtractFileExt(FName)) = '.DLL' then\tab /* Do only to DLL files*/ 
\par \pard\li480 begin 
\par \pard\li960\tx6000 ChangeFileExt( Zipper.filename, '.DL_');\tab /* Change the extention*/ 
\par ZipHeader.SetDateTime( Now );\tab /* Set the time to current time */ 
\par ZipHeader.Pathname := 'DEFAULT\\DLL';\tab /*  DLL's go into the DLL dir*/ 
\par ZipHeader.SetNewFileComment( 'This is a DLL' );\tab /* Create a comment for DLL's*/ 
\par \pard\li480 end; 
\par \pard end; 
\par \cf0  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble3490}
{\up $}{\footnote {\up $} OnUpdate event}
{\up +}{\footnote {\up +} vclzip:000530}
{\up K}{\footnote {\up K} Events;OnUpdate;}
{\up A}{\footnote {\up A} TVCLZip_OnUpdate;OnUpdate_Event;OnUpdate}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 OnUpdate event
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TVCLZip\cf3\strike0{\v Scribble3200}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  OnUpdate: TUpdateEvent = \b procedure\b0 (Sender: TObject; UDAction: TUpdateAction; FileIndex: Integer); \b of\b0  \b object\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The OnUpdate event is fired only when updating or freshening an existing archive.  It will be called for each file that is already in the archive and the UpdateAction will be passed in.  Each file will either be kept as is (uaKeeping) or replaced by a newer file (uaReplacing).
\par   
\par \f1 If a file is being saved, \cf2\strike OnFilePercentDone\cf3\strike0{\v Scribble2495}\cf0  and \cf2\strike OnTotalPercentDone\cf3\strike0{\v Scribble2530}\cf0  will also be called to show progress of the copy.\f0   
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4010}
{\up $}{\footnote {\up $} TSFXConfig component}
{\up +}{\footnote {\up +} kpsfxcfg:000010}
{\up K}{\footnote {\up K} TSFXConfig;TSFXConfig component;}
{\up A}{\footnote {\up A} TSFXConfig_Object;TSFXConfig}
}
\viewkind4\uc1\pard\keepn\cf4\b\f7\fs32 TSFXConfig component
\par \cf0\b0\fs16 
\par \pard\keepn\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf2\ul See also\cf3\ulnone{\v %Scribble4011}\tab\cf2\ul Properties\cf3\ulnone{\v %Scribble4012}\tab\cf2\ul Methods\cf3\ulnone{\v %Scribble4013}\cf5\cf0\b\fs22 
\par \pard\cf5\b0\fs20 
\par \cf0\b\fs22 Description
\par \pard\b0\f0 This unit allows for the easy  modification of options for the 32bit configurable SFX Delphi stub that is supplied with VCLZip.  Use this in conjunction with the \strike MakeNewSFX\strike0\fs24{\v Scribble3395}\fs22  method. 
\par  
\par The following properties and methods of TSFXConfig set the different options allowed in the 32bit SFX that is distributed with VCLZip.  
\par 
\par \b PUBLIC\b0  
\par 
\par \b procedure CreateHeader;\b0  
\par Call this method after you have set all options and you are ready to call \strike MakeNewSFX\strike0\fs24{\v Scribble3395}\fs22   This will actually create theHeader, which is the options header that is passed into MakeNewSFX. 
\par  
\par \b property theHeader: PChar read FHeader;\b0  
\par This is the options header that you pass into MakeNewSFX.  It will be placed between the sfx stub and the zip file when the SFX is created.  theHeader is created by calling CreateHeader after all options have been set.
\par   
\par \b property HeaderLen: WORD read FHeaderLen;\b0  
\par This is the length of the resulting options header that is created when you call CreateHeader.  This length is passed into MakeNewSFX along with theHeader.  
\par 
\par \b PUBLISHED
\par \b0  
\par \b property UserCanDisableCmdLine( Value: Boolean );\b0  
\par Setto True if you want the SFX dialog to have a checkbox which allows the user of the SFX to disable the running of the command line (see setStringData below to see how to set up the command line).  The default is False.  
\par 
\par Set to True if you want the SFX dialog to have a checkbox which allows the user of the SFX to disable the running of the command line (see setStringData below to see how to set up the command line).  The default is False.  
\par 
\par \b property UserCanChooseFiles: Boolean);\b0  
\par Set to True if you want the end user of the SFX to be able to select the files in the listbox to be extracted.  If set to False (the default), all files will be extracted. 
\par 
\par \b property UserCanChangeOverwrite: Boolean ;\b0  
\par Set to True if you want the end user to be able to determine the overwrite mode through a set of option buttons on the dialog box.  If set to False, the overwrite mode will be set to the default overwrite mode which you can set using the setOverwriteMode (below), and the end user won't be able to change it.  
\par 
\par \b property OverwriteMode: TsfxOverwriteMode ;\b0  
\par Set to the value you want the default overwrite mode to be.  The default value is omPrompt.  The allowable values are: 
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\cf4   omPrompt\cf0\tab A dialog box will be diplayed asking the user if they wish to overwrite an existing file with the file currently being unzipped. 
\par \cf4   omAlways\cf0\tab Always overwrite any existing files. 
\par \cf4   omNever\cf0\tab Never overwrite any existing files, do not extract if file already exists. 
\par \pard   
\par \b property AutoRun: Boolean ;\b0  
\par Setting this value to True will cause the SFX to automatically run and extract its contents to the destination path that you set in the call to setStringData (see below).  In this case, upon double clicking, the sfx will automatically run without any intervention from the user.  A window will not appear (unless you assign a value to InfoText in which case an information window will be shown before unzipping commences).  You can still have the sfx execute a program or file when done by setting the CmdLine property.
\par   
\par \b property Caption: String;\b0  
\par The SFX Dialog's caption
\par  
\par \pard\tx720\b property DefaultPath: String;\b0\tab   
\par \pard The default extraction directory shown in the dialog's target directory text box.  The user will be able to change this. If set to '><', the files will be extracted to the system temporary directory.  The default is '' which means the directory will first be set at the same directory as where the SFX itself resides. (e.g. "><readme\\test.txt" after an extraction to the path "C:\\Program files\\unpacked" means :  "c:\\progra~1\\unpacked\\readme\\test.txt") <- the short path will be created by zipsfx.
\par  
\par \b property  CmdLine: String;\b0  
\par The command line to execute after all files have been extracted. If the string "><" (greater than+less than) is somewhere in the command line, it will be replaced with the path where the archive has been extracted to.  
\par If the pipe "|" is in the command-line, the part to the left will get the application to run and the part to the right will be it's argument.  if the archive is extracted to e.g. "d:\\unpack", then we will get the following :  
\par 
\par \pard\fi-5400\li5400\tx5400\tx720\b Command Line\tab Will parse To:\b0   
\par \pard\fi-5400\li5400\tx5400 "><setup\\setup.exe|><install.inf"\tab run "d:\\unpack\\setup\\setup.exe" with parameters  "d:\\unpack\\install.inf".  
\par "c:\\windows\\notepad.exe|><readme.txt"\tab run "c:\\windows\\notepad.exe" with parameters  "d:\\unpack\\readme.txt".  
\par "><readme.txt"\tab open "d:\\unpack\\readme.txt" with its associated program, if there is any.  
\par "><setup.exe"  \tab run "d:\\unpack\\setup.exe" without special parameters. 
\par \pard   
\par \b property InfoText: String;\b0  
\par If InfoText is set to anything, then the first thing the sfx will do when it is run is show a window with this text in it.  This text can be set to whatever you want and it can include carraige returns too.  This information window will be shown even if AutoRun is set to True. 
\par  
\par \b property InfoTitle: String;\b0  
\par This will be the caption shown in the Information Window.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4011}
{\up $}{\footnote {\up $} TSFXConfig component - See also}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 See also
\par \cf0\b0 
\par \cf2\strike TVCLUnZip component\cf3\strike0{\v Scribble2300}\cf0 
\par \cf2\strike TVCLZip component\cf3\strike0{\v Scribble3200}\cf0 
\par \fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4012}
{\up $}{\footnote {\up $} TSFXConfig - Properties}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Properties
\par \cf0\b0 
\par \cf3\{bmct runtime.bmp\}\cf5  Run-time only\tab\cf3\{bmct key.bmp\}\cf5  Key properties
\par \pard\tx200\tx640\f6\tab\cf3\{bmct key.bmp\}\tab\cf2\strike AutoExtract\cf3\strike0{\v Scribble4020}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike Caption\cf3\strike0{\v Scribble4025}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike CmdLine\cf3\strike0{\v Scribble4030}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike DefaultPath\cf3\strike0{\v Scribble4035}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike HeaderLen\cf3\strike0{\v Scribble4040}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike InfoText\cf3\strike0{\v Scribble4045}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike InfoTitle\cf3\strike0{\v Scribble4050}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike OverwriteMode\cf3\strike0{\v Scribble2545}\cf5 
\par \cf3\{bmct runtime.bmp\}\tab\{bmct key.bmp\}\tab\cf2\strike theHeader\cf3\strike0{\v Scribble4060}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UserCanChangeOverwrite\cf3\strike0{\v Scribble4065}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UserCanChooseFiles\cf3\strike0{\v Scribble4070}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike UserCanDisableCmdLine\cf3\strike0{\v Scribble4075}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4013}
{\up $}{\footnote {\up $} TSFXConfig - Methods}
}
\viewkind4\uc1\pard\cf4\b\f7\fs20 Methods
\par \cf0\b0 
\par \cf3\{bmct key.bmp\}\cf5  Key methods
\par \pard\tx200\tx640\f6\tab\tab\cf2\strike Create\cf3\strike0{\v ! ALink("Create_Method")}\cf5 
\par \tab\cf3\{bmct key.bmp\}\tab\cf2\strike CreateHeader\cf3\strike0{\v Scribble4080}\cf5 
\par \cf0\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4020}
{\up $}{\footnote {\up $} AutoExtract property}
{\up +}{\footnote {\up +} kpsfxcfg:000020}
{\up K}{\footnote {\up K} AutoExtract;SFX;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_AutoExtract;AutoExtract_Property;AutoExtract}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 AutoExtract property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  AutoExtract: Boolean;
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 <<< Description of AutoExtract property >>>
\par \fs16 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4023}
{\up $}{\footnote {\up $} AutoRun property}
{\up +}{\footnote {\up +} kpsfxcfg:000030}
}
\viewkind4\uc1\pard\cf4\b\fs32 AutoRun property\cf0\b0\f7\fs20 
\par \fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Auto\f2 Run\f3 : Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setting this value to True will cause the SFX to automatically run and extract its contents to the destination path that you set in the call to setStringData (see below).  In this case, upon double clicking, the sfx will automatically run without any intervention from the user.  A window will not appear (unless you assign a value to InfoText in which case an information window will be shown before unzipping commences).  You can still have the sfx execute a program or file when done by setting the CmdLine property.  
\par \f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4025}
{\up $}{\footnote {\up $} Caption property}
{\up +}{\footnote {\up +} kpsfxcfg:000040}
{\up K}{\footnote {\up K} Caption;SFX;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_Caption;Caption_Property;Caption}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 Caption property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 
\par Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  Caption: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The SFX Dialog's caption 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4030}
{\up $}{\footnote {\up $} CmdLine property}
{\up +}{\footnote {\up +} kpsfxcfg:000050}
{\up K}{\footnote {\up K} CmdLine;SFX;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_CmdLine;CmdLine_Property;CmdLine}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CmdLine property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  CmdLine: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The command line to execute after all files have been extracted. If the string "><" (greater than+less than) is somewhere in the command line, it will be replaced with the path where the archive has been extracted to.  
\par 
\par If the pipe "|" is in the command-line, the part to the left will get the application to run and the part to the right will be it's argument.  if the archive is extracted to e.g. "d:\\unpack", then we will get the following :  
\par 
\par \pard\fi-5400\li5400\tx5400\tx720\b Command Line\tab Will parse To:\b0   
\par \pard\fi-5400\li5400\tx5400 "><setup\\setup.exe|><install.inf"\tab run "d:\\unpack\\setup\\setup.exe" with parameters  "d:\\unpack\\install.inf".  
\par "c:\\windows\\notepad.exe|><readme.txt"\tab run "c:\\windows\\notepad.exe" with parameters  "d:\\unpack\\readme.txt".  
\par "><readme.txt"\tab open "d:\\unpack\\readme.txt" with its associated program, if there is any.  
\par "><setup.exe"  \tab run "d:\\unpack\\setup.exe" without special parameters. 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640  \f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4035}
{\up $}{\footnote {\up $} DefaultPath property}
{\up +}{\footnote {\up +} kpsfxcfg:000060}
{\up K}{\footnote {\up K} DefaultPath;SFX;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_DefaultPath;DefaultPath_Property;DefaultPath}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 DefaultPath property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  DefaultPath: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 The default extraction directory shown in the dialog's target directory text box.  The user will be able to change this. If set to '><', the files will be extracted to the system temporary directory.  The default is '' which means the directory will first be set at the same directory as where the SFX itself resides. (e.g. "><readme\\test.txt" after an extraction to the path "C:\\Program files\\unpacked" means :  "c:\\progra~1\\unpacked\\readme\\test.txt") <- the short path will be created by zipsfx. 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f6\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4040}
{\up $}{\footnote {\up $} HeaderLen property}
{\up +}{\footnote {\up +} kpsfxcfg:000070}
{\up K}{\footnote {\up K} HeaderLen;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_HeaderLen;HeaderLen_Property;HeaderLen}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 HeaderLen property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  HeaderLen: WORD;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This is the length of the resulting options header that is created when you call CreateHeader.  This length is passed into MakeNewSFX along with theHeader.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4045}
{\up $}{\footnote {\up $} InfoText property}
{\up +}{\footnote {\up +} kpsfxcfg:000080}
{\up K}{\footnote {\up K} InfoText;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_InfoText;InfoText_Property;InfoText}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 InfoText property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  InfoText: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 If InfoText is set to anything, then the first thing the sfx will do when it is run is show a window with this text in it.  This text can be set to whatever you want and it can include carraige returns too.  This information window will be shown even if AutoRun is set to True.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4050}
{\up $}{\footnote {\up $} InfoTitle property}
{\up +}{\footnote {\up +} kpsfxcfg:000090}
{\up K}{\footnote {\up K} InfoTitle;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_InfoTitle;InfoTitle_Property;InfoTitle}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 InfoTitle property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  InfoTitle: \b string\b0 ;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This will be the caption shown in the Information Window.  
\par  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4060}
{\up $}{\footnote {\up $} theHeader property}
{\up +}{\footnote {\up +} kpsfxcfg:000100}
{\up K}{\footnote {\up K} theHeader;TSFXConfig;}
{\up A}{\footnote {\up A} TSFXConfig_theHeader;theHeader_Property;theHeader}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 theHeader property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  theHeader: PChar;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 This is the options header that you pass into MakeNewSFX.  It will be placed between the sfx stub and the zip file when the SFX is created.  theHeader is created by calling CreateHeader after all options have been set.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par Run-time only
\par Read-only
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4065}
{\up $}{\footnote {\up $} UserCanChangeOverwrite property}
{\up +}{\footnote {\up +} kpsfxcfg:000110}
{\up K}{\footnote {\up K} TSFXConfig;UserCanChangeOverwrite;}
{\up A}{\footnote {\up A} TSFXConfig_UserCanChangeOverwrite;UserCanChangeOverwrite_Property;UserCanChangeOverwrite}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UserCanChangeOverwrite property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  UserCanChangeOverwrite: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set to True if you want the end user to be able to determine the overwrite mode through a set of option buttons on the dialog box.  If set to False, the overwrite mode will be set to the default overwrite mode which you can set using the setOverwriteMode (below), and the end user won't be able to change it.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4070}
{\up $}{\footnote {\up $} UserCanChooseFiles property}
{\up +}{\footnote {\up +} kpsfxcfg:000120}
{\up K}{\footnote {\up K} TSFXConfig;UserCanChooseFiles;}
{\up A}{\footnote {\up A} TSFXConfig_UserCanChooseFiles;UserCanChooseFiles_Property;UserCanChooseFiles}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UserCanChooseFiles property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  UserCanChooseFiles: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set to True if you want the end user of the SFX to be able to select the files in the listbox to be extracted.  If set to False (the default), all files will be extracted. 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f6

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4073}
{\up $}{\footnote {\up $} OverwriteMode property}
{\up +}{\footnote {\up +} kpsfxcfg:000130}
}
\viewkind4\uc1\pard\cf4\b\fs32 OverwriteMode property\f7 
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  \f2 OverWriteMode\f3 : \b\f0\fs22 TsfxOverwriteMode\b0\f3\fs20  = (omPrompt, omAlways, omNever);
\par 
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Set to the value you want the default overwrite mode to be.  The default value is omPrompt.  The allowable values are: 
\par 
\par \pard\fi-2400\li2400\tx2400\tx720\cf4   omPrompt\cf0\tab A dialog box will be diplayed asking the user if they wish to overwrite an existing file with the file currently being unzipped. 
\par \cf4   omAlways\cf0\tab Always overwrite any existing files. 
\par \cf4   omNever\cf0\tab Never overwrite any existing files, do not extract if file already exists. 
\par \pard\f7\fs20 
\par 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4075}
{\up $}{\footnote {\up $} UserCanDisableCmdLine property}
{\up +}{\footnote {\up +} kpsfxcfg:000140}
{\up K}{\footnote {\up K} TSFXConfig;UserCanDisableCmdLine;}
{\up A}{\footnote {\up A} TSFXConfig_UserCanDisableCmdLine;UserCanDisableCmdLine_Property;UserCanDisableCmdLine}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 UserCanDisableCmdLine property
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 property\b0  UserCanDisableCmdLine: Boolean;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Setto True if you want the SFX dialog to have a checkbox which allows the user of the SFX to disable the running of the command line (see setStringData below to see how to set up the command line).  The default is False. 
\par  
\par Set to True if you want the SFX dialog to have a checkbox which allows the user of the SFX to disable the running of the command line (see setStringData below to see how to set up the command line).  The default is False.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs20 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4080}
{\up $}{\footnote {\up $} CreateHeader method}
{\up +}{\footnote {\up +} kpsfxcfg:000150}
{\up K}{\footnote {\up K} CreateHeader;SFX;}
{\up A}{\footnote {\up A} TSFXConfig_CreateHeader;CreateHeader_Method;CreateHeader}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 CreateHeader method
\par \cf0\b0\fs16 
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\b\fs22 Applies to
\par \cf2\b0\strike\fs20 TSFXConfig\cf3\strike0{\v Scribble4010}\cf5  component
\par 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 procedure\b0  CreateHeader;
\par \f7 
\par \b\fs22 Description
\par \pard\b0\f0 Call this method after you have set all options and you are ready to call \strike MakeNewSFX\strike0\fs24{\v Scribble3395}\fs22   This will actually create theHeader, which is the options header that is passed into MakeNewSFX.  
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\f7\fs16 
\par \pard\plain\f7

{\page}

{\pard\plain\f0\fs20
{\up #}{\footnote {\up #} Scribble4100}
{\up $}{\footnote {\up $} TsfxOverwriteMode type}
{\up +}{\footnote {\up +} kpsfxcfg:000160}
{\up K}{\footnote {\up K} TsfxOverwriteMode;}
}
\viewkind4\uc1\pard\cf4\b\f7\fs32 TsfxOverwriteMode type
\par \pard\tx1440\tx2880\tx4320\tx5760\tx7200\tx8640\cf5\b0\fs20 
\par \cf0\b\fs22 Declaration
\par \f3\fs20 type\b0  TsfxOverwriteMode = (omPrompt, omAlways, omNever);
\par \f7 
\par \b\fs22 Description
\par \b0\fs20 <<< Description of TsfxOverwriteMode type >>>
\par \fs16 
}
